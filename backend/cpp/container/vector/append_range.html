std::vector[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::vector

Member types

Member functions



vector::vector

vector::~vector

vector::operator=

vector::assign

vector::assign_range(C++23)  

vector::get_allocator

Element access

vector::operator[]

vector::at

vector::data

vector::front

vector::back

Iterators

vector::beginvector::cbegin(C++11)

vector::endvector::cend(C++11)

vector::rbeginvector::crbegin(C++11)

vector::rendvector::crend(C++11)



Capacity

vector::empty

vector::size

vector::max_size

vector::reserve

vector::capacity

vector::shrink_to_fit(DR*)

Modifiers

vector::clear

vector::erase

vector::insert

vector::insert_range(C++23)

vector::append_range(C++23)

vector::emplace(C++11)

vector::emplace_back(C++11)

vector::push_back

vector::pop_back

vector::resize

vector::swap











Non-member functions



operator==operator<=>(C++20)

swap(std::vector)

erase(std::vector)erase_if(std::vector)(C++20)(C++20)



operator!=operator<operator>operator<=operator>=(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)



Deduction guides(C++17)

[edit] 





template< container-compatible-range<T> R >

constexpr void append_range( R&& rg );

 

(since C++23)







Inserts copies of elements from the range rg before end(), in non-reversing order.

If after the operation the new size() is greater than old capacity() a reallocation takes place, in which case all iterators (including the end() iterator) and all references to the elements are invalidated. Otherwise only the end() iterator is invalidated.

Each iterator in rg is dereferenced exactly once.



Contents



1 Parameters

2 Complexity

3 Exceptions

4 Notes

5 Example

6 See also





[edit] Parameters





 rg



 -



 a container compatible range, that is, an input_range whose elements are convertible to T





 Type requirements





 -If any of the following conditions is satisfied, the behavior is undefined:

 T is not EmplaceConstructible into vector from *ranges::begin(rg).

 T is not MoveInsertable into vector.







[edit] Complexity

If reallocation happens, linear in the number of elements of the resulting vector; otherwise, linear in the number of elements inserted plus the distance to the end().







If one of the following conditions is satisfied, performs at most one reallocation:



 R models approximately_sized_range and ranges::distance(rg) <= ranges::reserve_hint(rg) is true.

 R models forward_range and R does not model approximately_sized_range.





(since C++26)



[edit] Exceptions

If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of T or by any InputIterator operation there are no effects. If an exception is thrown while inserting a single element at the end and T is CopyInsertable or std::is_nothrow_move_constructible_v<T> is true, there are no effects. Otherwise, if an exception is thrown by the move constructor of a non-CopyInsertable T, the effects are unspecified.



 Notes





Feature-test macro

Value

Std

Feature





__cpp_lib_containers_ranges

202202L

(C++23)

Ranges-aware construction and insertion



[edit] Example

Run this code

#include <cassert>

#include <vector>

#include <list>

 

int main()

{

    auto head = std::vector{1, 2, 3, 4};

    const auto tail = std::list{-5, -6, -7};

#ifdef __cpp_lib_containers_ranges

    head.append_range(tail);

#else

    head.insert(head.end(), tail.cbegin(), tail.cend());

#endif

    assert((head == std::vector{1, 2, 3, 4, -5, -6, -7}));

}



[edit] See also





  insert_range(C++23)



  inserts a range of elements  (public member function)





  push_back



  adds an element to the end  (public member function)





  emplace_back(C++11)



  constructs an element in-place at the end  (public member function)









 





                    