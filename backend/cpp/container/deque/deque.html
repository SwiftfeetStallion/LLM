std::deque[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::deque

Member types

Member functions



deque::deque

deque::~deque

deque::operator=

deque::assign

deque::assign_range(C++23)  

deque::get_allocator

Element access

deque::at

deque::operator[]

deque::front

deque::back

Iterators

deque::begindeque::cbegin(C++11)

deque::enddeque::cend(C++11)

deque::rbegindeque::crbegin(C++11)

deque::renddeque::crend(C++11)







Capacity

deque::empty

deque::size

deque::max_size

deque::shrink_to_fit(DR*)

Modifiers

deque::clear

deque::insert

deque::insert_range(C++23)

deque::emplace

deque::erase

deque::push_front

deque::emplace_front(C++11)

deque::prepend_range(C++23)

deque::pop_front

deque::push_back

deque::emplace_back(C++11)

deque::append_range(C++23)

deque::pop_back

deque::resize

deque::swap



Non-member functions



operator==operator<=>(C++20)

swap(std::deque)

erase(std::deque)erase_if(std::deque)(C++20)(C++20)



operator!=operator<operator>operator<=operator>=(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)



Deduction guides(C++17)

[edit] 





deque() : deque(Allocator()) {}

 (1)

(since C++11) (constexpr since C++26)









(2)







 explicit deque( const Allocator& alloc = Allocator() );

 

 (until C++11) 





explicit deque( const Allocator& alloc );

 

(since C++11) (constexpr since C++26)







explicit deque( size_type count,

                const Allocator& alloc = Allocator() );

 (3)

(since C++11) (constexpr since C++26)









(4)







explicit deque( size_type count, const T& value = T(),

                const Allocator& alloc = Allocator() );

 

(until C++11)





deque( size_type count, const T& value,

       const Allocator& alloc = Allocator() );

 

(since C++11) (constexpr since C++26)







template< class InputIt >

deque( InputIt first, InputIt last,



       const Allocator& alloc = Allocator() );

 (5)

(constexpr since C++26)





template< container-compatible-range<T> R >

deque( std::from_range_t, R&& rg,



       const Allocator& alloc = Allocator() );

 (6)

(since C++23) (constexpr since C++26)





deque( const deque& other );

 (7)

(constexpr since C++26)





deque( deque&& other );

 (8)

(since C++11) (constexpr since C++26)









(9)







 deque( const deque& other, const Allocator& alloc );

 

 (since C++11) (until C++23) 





deque( const deque& other,

       const std::type_identity_t<Allocator>& alloc );

 

(since C++23) (constexpr since C++26)











(10)







deque( deque&& other, const Allocator& alloc );

 

(since C++11) (until C++23)





deque( deque&& other, const std::type_identity_t<Allocator>& alloc );

 

(since C++23) (constexpr since C++26)







deque( std::initializer_list<T> init,

       const Allocator& alloc = Allocator() );

 (11)

(since C++11) (constexpr since C++26)







Constructs a new deque from a variety of data sources, optionally using a user supplied allocator alloc.



1) The default constructor since C++11. Constructs an empty deque with a default-constructed allocator.

 If Allocator is not DefaultConstructible, the behavior is undefined.

2) The default constructor until C++11. Constructs an empty deque with the given allocator alloc.

3) Constructs a deque with count default-inserted objects of T. No copies are made.

 If T is not DefaultInsertable into deque, the behavior is undefined.

4) Constructs a deque with count copies of elements with value value.





If T is not CopyInsertable into deque, the behavior is undefined.





(since C++11)



5) Constructs a deque with the contents of the range [first, last). Each iterator in [first, last) is dereferenced exactly once.





If InputIt does not satisfy the requirements of LegacyInputIterator, overload (4) is called instead with arguments static_cast<size_type>(first), last and alloc.





(until C++11)



This overload participates in overload resolution only if InputIt satisfies the requirements of LegacyInputIterator.

If T is not EmplaceConstructible into deque from *first, the behavior is undefined.





(since C++11)



6) Constructs a deque with the contents of the range rg. Each iterator in rg is dereferenced exactly once.

 If T is not EmplaceConstructible into deque from *ranges::begin(rg), the behavior is undefined.

7) The copy constructor. Constructs a deque with the contents of other.





The allocator is obtained as if by calling

std::allocator_traits<Allocator>::select_on_container_copy_construction        (other.get_allocator()).





(since C++11)



8) The move constructor. Constructs a deque with the contents of other. The allocator is obtained by move construction from other.get_allocator().

9) Same as the copy constructor, except that alloc is used as the allocator.

 If T is not CopyInsertable into deque, the behavior is undefined.

10) Same as the move constructor, except that alloc is used as the allocator.

 If T is not MoveInsertable into deque, the behavior is undefined.

11) Equivalent to deque(il.begin(), il.end(), alloc).

Contents



1 Parameters

2 Complexity

3 Exceptions

4 Notes

5 Example

6 Defect reports

7 See also





[edit] Parameters





 alloc



 -



 allocator to use for all memory allocations of this container





 count



 -



 the size of the container





 value



 -



 the value to initialize elements of the container with





 first, last



 -



 the pair of iterators defining the source range of elements to copy





 other



 -



 another container to be used as source to initialize the elements of the container with





 init



 -



 initializer list to initialize the elements of the container with





 rg



 -



 a container compatible range



[edit] Complexity

1,2) Constant.

3,4) Linear in count.

5) Linear in std::distance(first, last).

6) Linear in ranges::distance(rg).

7) Linear in other.size().

8) Constant.

9) Linear in other.size().

10) Linear in other.size() if alloc != other.get_allocator(), otherwise constant.

11) Linear in init.size().

[edit] Exceptions

Calls to Allocator::allocate may throw.



[edit] Notes

After container move construction (overloads (8) and (10)), references, pointers, and iterators (other than the end iterator) to other remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in [container.reqmts]/67, and a more direct guarantee is under consideration via LWG issue 2321.







Feature-test macro

Value

Std

Feature





__cpp_lib_containers_ranges

202202L

(C++23)

Ranges-aware construction and insertion; overload (6)



[edit] Example

Run this code

#include <deque>

#include <iostream>

#include <string>

 

template<typename T>

std::ostream& operator<<(std::ostream& s, const std::deque<T>& v)

{

    s.put('{');

    for (char comma[]{'\0', ' ', '\0'}; const auto& e : v)

        s << comma << e, comma[0] = ',';

    return s << "}\n";

}

 

int main()

{

    // C++11 initializer list syntax:

    std::deque<std::string> words1{"the", "frogurt", "is", "also", "cursed"};

    std::cout << "1: " << words1;

 

    // words2 == words1

    std::deque<std::string> words2(words1.begin(), words1.end());

    std::cout << "2: " << words2;

 

    // words3 == words1

    std::deque<std::string> words3(words1);

    std::cout << "3: " << words3;

 

    // words4 is {"Mo", "Mo", "Mo", "Mo", "Mo"}

    std::deque<std::string> words4(5, "Mo");

    std::cout << "4: " << words4;

 

    const auto rg = {"cat", "cow", "crow"};

#ifdef __cpp_lib_containers_ranges

    std::deque<std::string> words5(std::from_range, rg); // overload (6)

#else

    std::deque<std::string> words5(rg.begin(), rg.end()); // overload (5)

#endif

    std::cout << "5: " << words5;

}

Output:



1: {the, frogurt, is, also, cursed}

2: {the, frogurt, is, also, cursed}

3: {the, frogurt, is, also, cursed}

4: {Mo, Mo, Mo, Mo, Mo}

5: {cat, cow, crow}



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 144



C++98



the complexity requirement of overload (5) was the sameas that of the corresponding overload of std::vector



changed to linear complexity





LWG 237



C++98



the complexity requirement of overload(5) was linear in first - last



changed to linear instd::distance(first, last)





LWG 438



C++98



overload (5) would only call overload (4)if InputIt is an integral type



calls overload (4) if InputItis not an LegacyInputIterator





LWG 2193



C++11



the default constructor was explicit



made non-explicit





LWG 2210



C++11



overload (3) did not have an allocator parameter



added the parameter





N3346



C++11



for overload (3), the elements inthe container were value-initialized



they are default-inserted



[edit] See also





  assign



  assigns values to the container  (public member function) [edit]





  operator=



  assigns values to the container  (public member function) [edit]









 





                    