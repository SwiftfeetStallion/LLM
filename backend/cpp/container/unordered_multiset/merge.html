std::unordered_multiset[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::unordered_multiset

Member types

Member functions



unordered_multiset::unordered_multiset

unordered_multiset::~unordered_multiset  

unordered_multiset::operator=

unordered_multiset::get_allocator

Iterators

unordered_multiset::beginunordered_multiset::cbegin

unordered_multiset::endunordered_multiset::cend

Capacity

unordered_multiset::size

unordered_multiset::max_size

unordered_multiset::empty

Modifiers

unordered_multiset::clear

unordered_multiset::insert

unordered_multiset::insert_range(C++23)

unordered_multiset::emplace

unordered_multiset::emplace_hint

unordered_multiset::erase

unordered_multiset::swap

unordered_multiset::extract(C++17)

unordered_multiset::merge(C++17)



Lookup

unordered_multiset::count

unordered_multiset::find

unordered_multiset::contains(C++20)

unordered_multiset::equal_range

Bucket interface

unordered_multiset::begin(size_type)unordered_multiset::cbegin(size_type)

unordered_multiset::end(size_type)unordered_multiset::cend(size_type)

unordered_multiset::bucket_count

unordered_multiset::max_bucket_count

unordered_multiset::bucket_size

unordered_multiset::bucket

Hash policy

unordered_multiset::load_factor

unordered_multiset::max_load_factor

unordered_multiset::rehash

unordered_multiset::reserve

Observers

unordered_multiset::hash_function

unordered_multiset::key_eq



Non-member functions



operator==operator!=(until C++20)



std::swap(std::unordered_multiset)

erase_if(std::unordered_multiset)(C++20)



Deduction guides (C++17)

[edit] 





template< class H2, class P2 >

void merge( std::unordered_set<Key, H2, P2, Allocator>& source );

 (1)

(since C++17) (constexpr since C++26)





template< class H2, class P2 >

void merge( std::unordered_set<Key, H2, P2, Allocator>&& source );

 (2)

(since C++17) (constexpr since C++26)





template< class H2, class P2 >

void merge( std::unordered_multiset<Key, H2, P2, Allocator>& source );

 (3)

(since C++17) (constexpr since C++26)





template< class H2, class P2 >

void merge( std::unordered_multiset<Key, H2, P2, Allocator>&& source );

 (4)

(since C++17) (constexpr since C++26)







Attempts to extract (“splice”) each element in source and insert it into *this using the hash function and key equality predicate of *this.

If get_allocator() == source.get_allocator() is false, the behavior is undefined.

No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source.Iterators referring to the transferred elements and all iterators referring to *this are invalidated.



Contents



1 Parameters

2 Complexity

3 Example

4 See also





[edit] Parameters





 source



 -



 compatible container to transfer the nodes from



[edit] Complexity

Given \(\scriptsize S\)S as size() and \(\scriptsize N\)N as source.size():



1-4) Average case \(\scriptsize O(N)\)O(N), worst case \(\scriptsize O(N \cdot S + N)\)O(N·S+N).

[edit] Example

Run this code

#include <iostream>

#include <unordered_set>

 

// print out a container

template<class Os, class K>

Os& operator<<(Os& os, const std::unordered_multiset<K>& v)

{

    os << '[' << v.size() << "] {";

    bool o{};

    for (const auto& e : v)

        os << (o ? ", " : (o = 1, " ")) << e;

    return os << " }\n";

}

 

int main()

{

    std::unordered_multiset<char>

        p{'C', 'B', 'B', 'A'}, 

        q{'E', 'D', 'E', 'C'};

 

    std::cout << "p: " << p << "q: " << q;

 

    p.merge(q);

 

    std::cout << "p.merge(q);\n" << "p: " << p << "q: " << q;

}

Possible output:



p: [4] { A, B, B, C }

q: [4] { C, D, E, E }

p.merge(q);

p: [8] { E, E, D, A, B, B, C, C }

q: [0] { }



[edit] See also





  extract(C++17)



  extracts nodes from the container  (public member function) [edit]





  insert



  inserts elements or nodes(since C++17)  (public member function) [edit]









 





                    