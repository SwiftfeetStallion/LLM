std::flat_multimap[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::flat_multimap

Member types

Member functions





flat_multimap::flat_multimap  

flat_multimap::operator=

Modifiers

flat_multimap::clear

flat_multimap::erase

flat_multimap::swap

flat_multimap::extract

flat_multimap::replace

flat_multimap::insert

flat_multimap::insert_range

flat_multimap::emplace

flat_multimap::emplace_hint

Lookup

flat_multimap::count

flat_multimap::find

flat_multimap::contains

flat_multimap::equal_range

flat_multimap::lower_bound

flat_multimap::upper_bound



Iterators

flat_multimap::beginflat_multimap::cbegin

flat_multimap::endflat_multimap::cend

flat_multimap::rbeginflat_multimap::crbegin

flat_multimap::rendflat_multimap::crend

Capacity

flat_multimap::size

flat_multimap::max_size

flat_multimap::empty

Observers

flat_multimap::key_comp

flat_multimap::keys

flat_multimap::value_comp

flat_multimap::values





Non-member functions





swap(std::flat_multimap)

erase_if(std::flat_multimap)   



operator==operator<=>





Helper classes





uses_allocator<std::flat_multimap>





Tags





sorted_equivalent        



sorted_equivalent_t





Deduction guides

[edit] 





iterator find( const Key& key );

 (1)

(since C++23) (constexpr since C++26)





const_iterator find( const Key& key ) const;

 (2)

(since C++23) (constexpr since C++26)





template< class K >

iterator find( const K& x );

 (3)

(since C++23) (constexpr since C++26)





template< class K >

const_iterator find( const K& x ) const;

 (4)

(since C++23) (constexpr since C++26)







1,2) Finds an element with key equivalent to key.If there are several elements with the requested key in the container, any of them may be returned.

3,4) Finds an element with key that compares equivalent to x.

 This overload participates in overload resolution only if Compare is transparent. It allows calling this function without constructing an instance of Key.

Contents



1 Parameters

2 Return value

3 Complexity

4 Example

5 See also





[edit] Parameters





 key



 -



 key value of the element to search for





 x



 -



 a value of any type that can be transparently compared with a key



[edit] Return value

An iterator to the requested element. If no such element is found, past-the-end (see end()) iterator is returned.



[edit] Complexity

Logarithmic in the size of the container.



[edit] Example

Run this code

#include <iostream>

#include <flat_map>

 

struct LightKey

{

    int x;

};

 

struct FatKey

{

    int x;

    int data[1000]; // a heavy blob

};

 

// As detailed above, the container must use std::less<> (or other transparent

// Comparator) to access these overloads. This includes standard overloads,

// such as comparison between std::string and std::string_view.

bool operator<(const FatKey& fk, const LightKey& lk) { return fk.x < lk.x; }

bool operator<(const LightKey& lk, const FatKey& fk) { return lk.x < fk.x; }

bool operator<(const FatKey& fk1, const FatKey& fk2) { return fk1.x < fk2.x; }

 

int main()

{

    // Simple comparison demo.

    std::flat_multimap<int, char> example{{1, 'a'}, {2, 'b'}};

 

    if (auto search = example.find(2); search != example.end())

        std::cout << "Found " << search->first << ' ' << search->second << '\n';

    else

        std::cout << "Not found\n";

 

    // Transparent comparison demo.

    std::flat_multimap<FatKey, char, std::less<>> example2{{{1, {}}, 'a'}, {{2, {}}, 'b'}};

 

    LightKey lk = {2};

    if (auto search = example2.find(lk); search != example2.end())

        std::cout << "Found " << search->first.x << ' ' << search->second << '\n';

    else

        std::cout << "Not found\n";

 

    // Obtaining const iterators.

    // Compiler decides whether to return iterator of (non) const type by way of

    // accessing map; to prevent intentional modification, one of the simplest

    // options is to access the map via a constant reference.

    const auto& example2ref = example2;

    if (auto search = example2ref.find(lk); search != example2.end())

    {

        std::cout << "Found " << search->first.x << ' ' << search->second << '\n';

    //  search->second = 'c'; // error: assignment of member

                              // 'std::pair<const FatKey, char>::second'

                              // in read-only object

    }

}

Output:



Found 2 b

Found 2 b

Found 2 b



[edit] See also





  count



  returns the number of elements matching specific key  (public member function) [edit]





  equal_range



  returns range of elements matching a specific key  (public member function) [edit]









 





                    