std::mdspan[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::mdspan



Member functions

mdspan::mdspan

mdspan::operator=

Element access

mdspan::operator[]

Observers

mdspan::rank

mdspan::rank_dynamic

mdspan::static_extent

mdspan::extent

mdspan::size

mdspan::empty

mdspan::stride

mdspan::extents

mdspan::data_handle

mdspan::mapping

mdspan::accessor

mdspan::is_uniquemdspan::is_exhaustivemdspan::is_stridedmdspan::is_always_uniquemdspan::is_always_exhaustivemdspan::is_always_strided  







Non-member functions

swap(std::mdspan)

Subviews

submdspan(C++26)

submdspan_extents(C++26)

Helper types and templates

extentsdextents

dims(C++26)

default_accessor

aligned_accessor(C++26)

Layout mapping policies

layout_left

layout_right

layout_stride

layout_left_padded(C++26)

layout_right_padded(C++26)

Subviews helpers

full_extent(C++26)

strided_slice(C++26)

submdspan_mapping_result(C++26)

Deduction guides



[edit] 





 template< class... OtherIndexTypes >

constexpr reference operator[]( OtherIndexTypes... indices ) const;

 (1) 

 (since C++23) 





 template< class OtherIndexType >

constexpr reference operator[]



    ( std::span<OtherIndexType, rank()> indices ) const;

 (2) 

 (since C++23) 





 template< class OtherIndexType >

constexpr reference operator[]



    ( const std::array<OtherIndexType, rank()>& indices ) const;

 (3) 

 (since C++23) 







Returns a reference to the indicesth element of the mdspan.



1) Equivalent to return acc_ ﻿.access(ptr_, map_ ﻿(static_cast<index_type>(std::move(indices))...));.

 This overload participates in overload resolution only if all following values are true:

 (std::is_convertible_v<OtherIndexTypes, index_type> && ...)

 (std::is_nothrow_constructible_v<index_type, OtherIndexTypes> && ...)

 sizeof...(OtherIndexTypes) == rank()



 



If extents_type::index-cast ﻿(std::move(indices)) is not a multidimensional index in extents(), the behavior is undefined.





(until C++26)



If extents_type::index-cast ﻿(std::move(indices)) is not a multidimensional index in extents():



 If the implementation is hardened, a contract violation occurs. Moreover, if the contract-violation handler returns under “observe” evaluation semantic, the behavior is undefined.

 If the implementation is not hardened, the behavior is undefined.





(since C++26)



2,3) Let P be a parameter pack such that std::is_same_v<std::make_index_sequence<rank()>,               std::index_sequence<P...>> is true, equivalent to return operator[](extents_type::index-cast ﻿(std::as_const(indices[P]))...);.

 This overload participates in overload resolution only if all following values are true:

 std::is_convertible_v<const OtherIndexType&, index_type>

 std::is_nothrow_constructible_v<index_type, const OtherIndexType&>



Contents



1 Parameters

2 Return value

3 Example

4 Defect reports

5 See also





[edit] Parameters





 indices



 -



 the indices of the element to access



[edit] Return value

A reference to the element.



[edit] Example

This section is incompleteReason: no example 

[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 3974



C++23



overloads (2,3) did not apply extents_type::index-cast



applies



[edit] See also

This section is incomplete 





 





                    