std::multiset[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::multiset

Member functions





multiset::multiset

multiset::~multiset       



multiset::operator=

multiset::get_allocator









Iterators

multiset::beginmultiset::cbegin(C++11)

multiset::endmultiset::cend(C++11)

multiset::rbeginmultiset::crbegin(C++11)    

multiset::rendmultiset::crend(C++11)

Capacity

multiset::size

multiset::max_size

multiset::empty

Observers

multiset::key_comp

multiset::value_comp



Modifiers

multiset::clear

multiset::erase

multiset::swap

multiset::extract(C++17)

multiset::merge(C++17)

multiset::insert

multiset::insert_range(C++23)

multiset::emplace(C++11)

multiset::emplace_hint(C++11)

Lookup

multiset::count

multiset::find

multiset::contains(C++20)

multiset::equal_range

multiset::lower_bound

multiset::upper_bound





Non-member functions





std::swap(std::multiset)

erase_if(std::multiset)(C++20)  

operator==operator<=>(C++20)







operator!=operator<operator>operator<=operator>=(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)





Deduction guides(C++17)

[edit] 





multiset& operator=( const multiset& other );

 (1)

(constexpr since C++26)









(2)







multiset& operator=( multiset&& other );

 

(since C++11) (until C++17)





multiset& operator=( multiset&& other )

    noexcept(/* see below */);

 

(since C++17) (constexpr since C++26)







multiset& operator=( std::initializer_list<value_type> ilist );

 (3)

(since C++11) (constexpr since C++26)







Replaces the contents of the container.

Let traits be std::allocator_traits<allocator_type>:



1) Copy assignment operator. Replaces the contents with a copy of the contents of other.





If traits::propagate_on_container_copy_assignment::value is true, the allocator of *this is replaced by a copy of other. If the allocator of *this after assignment would compare unequal to its old value, the old allocator is used to deallocate the memory, then the new allocator is used to allocate it before copying the elements. Otherwise, the memory owned by *this may be reused when possible. In any case, the elements originally belonging to *this may be either destroyed or replaced by element-wise copy-assignment.





(since C++11)



2) Move assignment operator. Replaces the contents with those of other using move semantics (i.e. the data in other is moved from other into this container). other is in a valid but unspecified state afterwards.

 If traits::propagate_on_container_move_assignment::value is true, the allocator of *this is replaced by a copy of that of other. If it is false and the allocators of *this and other do not compare equal, *this cannot take ownership of the memory owned by other and must move-assign each element individually, allocating additional memory using its own allocator as needed. In any case, all elements originally belonging to *this are either destroyed or replaced by element-wise move-assignment.

3) Replaces the contents with those identified by initializer list ilist.

Contents



1 Parameters

2 Return value

3 Complexity

4 Exceptions

5 Notes

6 Example

7 See also





[edit] Parameters





 other



 -



 another container to use as data source





 ilist



 -



 initializer list to use as data source



[edit] Return value

*this



[edit] Complexity

1) Linear in the size of *this and other.

2) Linear in the size of *this unless the allocators do not compare equal and do not propagate, in which case linear in the size of *this and other.

3) \(\scriptsize O(N \cdot \log(N))\)O(N·log(N)) in general, where \(\scriptsize N\)N is size() + ilist.size(). Linear if ilist is sorted with respect to value_comp().

[edit] Exceptions





2) noexcept specification:  

noexcept(std::allocator_traits<Allocator>::is_always_equal::value

&& std::is_nothrow_move_assignable<Compare>::value)



(since C++17)



[edit] Notes

After container move assignment (overload (2)), unless element-wise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to other remain valid, but refer to elements that are now in *this. The current standard makes this guarantee via the blanket statement in [container.reqmts]/67, and a more direct guarantee is under consideration via LWG issue 2321.



[edit] Example

The following code uses operator= to assign one std::multiset to another:Run this code

#include <initializer_list>

#include <iostream>

#include <iterator>

#include <set>

 

void print(const auto comment, const auto& container)

{

    auto size = std::size(container);

    std::cout << comment << "{ ";

    for (const auto& element : container)

        std::cout << element << (--size ? ", " : " ");

    std::cout << "}\n";

}

 

int main()

{

    std::multiset<int> x{1, 2, 3}, y, z;

    const auto w = {4, 5, 6, 7};

 

    std::cout << "Initially:\n";

    print("x = ", x);

    print("y = ", y);

    print("z = ", z);

 

    std::cout << "Copy assignment copies data from x to y:\n";

    y = x;

    print("x = ", x);

    print("y = ", y);

 

    std::cout << "Move assignment moves data from x to z, modifying both x and z:\n";

    z = std::move(x);

    print("x = ", x);

    print("z = ", z);

 

    std::cout << "Assignment of initializer_list w to z:\n";

    z = w;

    print("w = ", w);

    print("z = ", z);

}

Output:



Initially:

x = { 1, 2, 3 }

y = { }

z = { }

Copy assignment copies data from x to y:

x = { 1, 2, 3 }

y = { 1, 2, 3 }

Move assignment moves data from x to z, modifying both x and z:

x = { }

z = { 1, 2, 3 }

Assignment of initializer_list w to z:

w = { 4, 5, 6, 7 }

z = { 4, 5, 6, 7 }



[edit] See also





  (constructor)



  constructs the multiset  (public member function) [edit]









 





                    