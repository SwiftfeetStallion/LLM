std::list[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::list

Member functions



list::list

list::~list

list::operator=

list::assign

list::assign_range(C++23)  

list::get_allocator

Element access

list::front

list::back

Iterators

list::beginlist::cbegin(C++11)

list::endlist::cend(C++11)

list::rbeginlist::crbegin(C++11)

list::rendlist::crend(C++11)

Capacity

list::size

list::empty

list::max_size



Modifiers

list::clear

list::insert

list::insert_range(C++23)

list::emplace(C++11)

list::erase

list::push_front

list::emplace_front(C++11)

list::prepend_range(C++23)

list::pop_front

list::push_back

list::emplace_back(C++11)

list::append_range(C++23)

list::pop_back

list::resize

list::swap

Operations

list::merge

list::splice

list::removelist::remove_if

list::reverse

list::unique

list::sort



Non-member functions



operator==operator<=>(C++20)

swap(std::list)

erase(std::list)erase_if(std::list)(C++20)(C++20)



operator!=operator<operator>operator<=operator>=(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)



Deduction guides(C++17)

[edit] 





void merge( list& other );

 (1)

(constexpr since C++26)





void merge( list&& other );

 (2)

(since C++11) (constexpr since C++26)





template< class Compare > 

void merge( list& other, Compare comp );

 (3)

(constexpr since C++26)





template< class Compare > 

void merge( list&& other, Compare comp );

 (4)

(since C++11) (constexpr since C++26)







Merges two sorted lists into one sorted list.



 If other refers to the same object as *this, does nothing.

 Otherwise, transfers all elements from other to *this. other is empty after the merge.



This operation is stable:



 For equivalent elements in the two lists, the elements from *this always precede the elements from other.

 The order of equivalent elements of *this and other does not change.



1,2) Equivalent to merge(other, std::less<T>())(until C++14)merge(other, std::less<>())(since C++14).

3,4) Elements are compared using comp.

 If any of the following conditions is satisfied, the behavior is undefined:

 *this or other is not sorted with respect to the comparator comp.

 get_allocator() == other.get_allocator() is false.



No iterators or references become invalidated. The pointers and references to the elements moved from *this, as well as the iterators referring to these elements, will refer to the same elements of *this, instead of other.



Contents



1 Parameters

2 Exceptions

3 Complexity

4 Example

5 Defect reports

6 See also





[edit] Parameters





 other



 -



 another container to merge





 comp



 -



 comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second. 

The signature of the comparison function should be equivalent to the following:

bool cmp(const Type1& a, const Type2& b);

While the signature does not need to have const&, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1& is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy(since C++11)).

The types Type1 and Type2 must be such that an object of type list<T, Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them.

​







 Type requirements





 -Compare must meet the requirements of Compare.



[edit] Exceptions

If an exception is thrown for any reason, these functions have no effect (strong exception safety guarantee). Except if the exception comes from a comparison.



[edit] Complexity

If other refers to the same object as *this, no comparisons are performed.

Otherwise, given \(\scriptsize N_1\)N1 as std::distance(begin(), end()) and \(\scriptsize N_2\)N2 as std::distance(other.begin(), other.end()):



1,2) At most \(\scriptsize N_1 + N_2 - 1\)N1+N2-1 comparisons using operator<.

3,4) At most \(\scriptsize N_1 + N_2 - 1\)N1+N2-1 applications of the comparison function comp.

[edit] Example

Run this code

#include <iostream>

#include <list>

 

std::ostream& operator<<(std::ostream& ostr, const std::list<int>& list)

{

    for (const int i : list)

        ostr << ' ' << i;

    return ostr;

}

 

int main()

{

    std::list<int> list1 = {5, 9, 1, 3, 3};

    std::list<int> list2 = {8, 7, 2, 3, 4, 4};

 

    list1.sort();

    list2.sort();

    std::cout << "list1: " << list1 << '\n';

    std::cout << "list2: " << list2 << '\n';

 

    list1.merge(list2);

    std::cout << "merged:" << list1 << '\n';

}

Output:



list1:  1 3 3 5 9

list2:  2 3 4 4 7 8

merged: 1 2 3 3 3 4 4 5 7 8 9



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 300



C++98



the effect when *this and other referto the same object was not specified



specified as no-op





LWG 1207



C++98



it was unclear whether iterators and/or references will be invalidated



keep valid





LWG 1215



C++98



O(1) node moving could not be guaranteed ifget_allocator() != other.get_allocator()



the behavior isundefined in this case





LWG 3088



C++98



operator< could misbehave for pointer elements



implementation-definedstrict total order used



[edit] See also





  splice



  transfers elements from another list  (public member function) [edit]





  merge



  merges two sorted ranges  (function template) [edit]





  inplace_merge



  merges two ordered ranges in-place  (function template) [edit]





  ranges::merge(C++20)



 merges two sorted ranges(algorithm function object)[edit]





  ranges::inplace_merge(C++20)



 merges two ordered ranges in-place(algorithm function object)[edit]









 





                    