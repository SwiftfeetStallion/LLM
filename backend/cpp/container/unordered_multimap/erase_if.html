std::erase_if (std::unordered_multimap)









From cppreference.com





[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::unordered_multimap

Member types

Member functions



unordered_multimap::unordered_multimap

unordered_multimap::~unordered_multimap  

unordered_multimap::operator=

unordered_multimap::get_allocator

Iterators

unordered_multimap::beginunordered_multimap::cbegin

unordered_multimap::endunordered_multimap::cend

Capacity

unordered_multimap::size

unordered_multimap::max_size

unordered_multimap::empty

Modifiers

unordered_multimap::clear

unordered_multimap::insert

unordered_multimap::insert_range(C++23)

unordered_multimap::emplace

unordered_multimap::emplace_hint

unordered_multimap::erase

unordered_multimap::swap

unordered_multimap::extract(C++17)

unordered_multimap::merge(C++17)



Lookup

unordered_multimap::count

unordered_multimap::find

unordered_multimap::contains(C++20)

unordered_multimap::equal_range

Bucket interface

unordered_multimap::begin(size_type)unordered_multimap::cbegin(size_type)

unordered_multimap::end(size_type)unordered_multimap::cend(size_type)

unordered_multimap::bucket_count

unordered_multimap::max_bucket_count

unordered_multimap::bucket_size

unordered_multimap::bucket

Hash policy

unordered_multimap::load_factor

unordered_multimap::max_load_factor

unordered_multimap::rehash

unordered_multimap::reserve

Observers

unordered_multimap::hash_function

unordered_multimap::key_eq



Non-member functions



std::swap(std::unordered_multimap)

erase_if(std::unordered_multimap)(C++20)



operator==operator!=(until C++20)



Deduction guides (C++17)

[edit] 





 Defined in header <unordered_map>











template< class Key, class T, class Hash, class KeyEqual, class Alloc,

          class Pred >

std::unordered_multimap<Key, T, Hash, KeyEqual, Alloc>::size_type

    erase_if( std::unordered_multimap<Key, T, Hash, KeyEqual, Alloc>& c,



              Pred pred );

 

(since C++20) (constexpr since C++26)







Erases all elements that satisfy the predicate pred from c.

Equivalent to



auto old_size = c.size();

for (auto first = c.begin(), last = c.end(); first != last;)

{

    if (pred(*first))

        first = c.erase(first);

    else

        ++first;

}

return old_size - c.size();

Contents



1 Parameters

2 Return value

3 Complexity

4 Example

5 See also





[edit] Parameters





 c



 -



 container from which to erase





 pred



 -



 predicate that returns true if the element should be erased



[edit] Return value

The number of erased elements.



[edit] Complexity

Linear.



[edit] Example

Run this code

#include <iostream>

#include <unordered_map>

 

void println(auto rem, const auto& container)

{

    std::cout << rem << '{';

    for (char sep[]{0, ' ', 0}; const auto& [key, value] : container)

        std::cout << sep << '{' << key << ", " << value << '}', *sep = ',';

    std::cout << "}\n";

}

 

int main()

{

    std::unordered_multimap<int, char> data

    {

        {1, 'a'}, {2, 'b'}, {3, 'c'}, {4, 'd'},

        {5, 'e'}, {4, 'f'}, {5, 'g'}, {5, 'g'},

    };

    println("Original:\n", data);

 

    const auto count = std::erase_if(data, [](const auto& item)

    {

        const auto& [key, value] = item;

        return (key & 1) == 1;

    });

 

    println("Erase items with odd keys:\n", data);

    std::cout << count << " items removed.\n";

}

Possible output:



Original:

{{5, g}, {5, g}, {5, e}, {4, f}, {4, d}, {3, c}, {2, b}, {1, a}}

Erase items with odd keys:

{{4, f}, {4, d}, {2, b}}

5 items removed.



[edit] See also





  removeremove_if



  removes elements satisfying specific criteria  (function template) [edit]





  ranges::removeranges::remove_if(C++20)(C++20)



 removes elements satisfying specific criteria(algorithm function object)[edit]









 





                    