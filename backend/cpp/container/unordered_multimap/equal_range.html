std::unordered_multimap[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::unordered_multimap

Member types

Member functions



unordered_multimap::unordered_multimap

unordered_multimap::~unordered_multimap  

unordered_multimap::operator=

unordered_multimap::get_allocator

Iterators

unordered_multimap::beginunordered_multimap::cbegin

unordered_multimap::endunordered_multimap::cend

Capacity

unordered_multimap::size

unordered_multimap::max_size

unordered_multimap::empty

Modifiers

unordered_multimap::clear

unordered_multimap::insert

unordered_multimap::insert_range(C++23)

unordered_multimap::emplace

unordered_multimap::emplace_hint

unordered_multimap::erase

unordered_multimap::swap

unordered_multimap::extract(C++17)

unordered_multimap::merge(C++17)



Lookup

unordered_multimap::count

unordered_multimap::find

unordered_multimap::contains(C++20)

unordered_multimap::equal_range

Bucket interface

unordered_multimap::begin(size_type)unordered_multimap::cbegin(size_type)

unordered_multimap::end(size_type)unordered_multimap::cend(size_type)

unordered_multimap::bucket_count

unordered_multimap::max_bucket_count

unordered_multimap::bucket_size

unordered_multimap::bucket

Hash policy

unordered_multimap::load_factor

unordered_multimap::max_load_factor

unordered_multimap::rehash

unordered_multimap::reserve

Observers

unordered_multimap::hash_function

unordered_multimap::key_eq



Non-member functions



std::swap(std::unordered_multimap)

erase_if(std::unordered_multimap)(C++20)



operator==operator!=(until C++20)



Deduction guides (C++17)

[edit] 





 std::pair<iterator, iterator> equal_range( const Key& key );

 (1) 

 (since C++11) 





 std::pair<const_iterator, const_iterator> equal_range( const Key& key ) const;

 (2) 

 (since C++11) 





 template< class K >

std::pair<iterator, iterator> equal_range( const K& x );

 (3) 

 (since C++20) 





 template< class K >

std::pair<const_iterator, const_iterator> equal_range( const K& x ) const;

 (4) 

 (since C++20) 







1,2) Returns a range containing all elements with key key in the container. The range is defined by two iterators, the first pointing to the first element of the wanted range and the second pointing past the last element of the range.

3,4) Returns a range containing all elements in the container with key equivalent to x. This overload participates in overload resolution only if  Hash and KeyEqual are both transparent. This assumes that such Hash is callable with both K and Key type, and that the KeyEqual is transparent, which, together, allows calling this function without constructing an instance of Key.

Contents



1 Parameters

2 Return value

3 Complexity

4 Notes

5 Example

6 See also





[edit] Parameters





 key



 -



 key value to compare the elements to





 x



 -



 a value of any type that can be transparently compared with a key



[edit] Return value

std::pair containing a pair of iterators defining the wanted range. If there are no such elements, past-the-end (see end()) iterators are returned as both elements of the pair.



[edit] Complexity

Average case linear in the number of elements with the key key, worst case linear in the size of the container.



[edit] Notes





Feature-test macro

Value

Std

Feature





__cpp_lib_generic_unordered_lookup

201811L

(C++20)

Heterogeneous comparison lookup in unordered associative containers, overloads (3,4)



[edit] Example

Run this code

#include <iostream>

#include <unordered_map>

 

int main()

{

    std::unordered_multimap<int,char> map = {{1, 'a'},{1, 'b'},{1, 'd'},{2, 'b'}};

    auto range = map.equal_range(1);

    for (auto it = range.first; it != range.second; ++it)

        std::cout << it->first << ' ' << it->second << '\n';

}

Output:



1 a

1 b

1 d



[edit] See also





  find



  finds element with specific key  (public member function) [edit]





  contains(C++20)



  checks if the container contains element with specific key  (public member function) [edit]





  count



  returns the number of elements matching specific key  (public member function) [edit]





  equal_range



  returns range of elements matching a specific key  (function template) [edit]









 





                    