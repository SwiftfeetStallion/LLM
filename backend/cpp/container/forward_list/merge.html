std::forward_list[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::forward_list

Member functions



forward_list::forward_list

forward_list::~forward_list

forward_list::operator=

forward_list::assign

forward_list::assign_range(C++23)  

forward_list::get_allocator

Element access

forward_list::front

Iterators

forward_list::before_beginforward_list::cbefore_begin

forward_list::beginforward_list::cbegin

forward_list::endforward_list::cend

Capacity

forward_list::empty

forward_list::max_size



Modifiers

forward_list::clear

forward_list::emplace_front

forward_list::push_front

forward_list::insert_after

forward_list::emplace_after

forward_list::erase_after

forward_list::insert_range_after(C++23)

forward_list::prepend_range(C++23)

forward_list::pop_front

forward_list::resize

forward_list::swap

Operations

forward_list::merge

forward_list::splice_after

forward_list::removeforward_list::remove_if

forward_list::reverse

forward_list::unique

forward_list::sort



Non-member functions



operator==operator<=>(C++20)

swap(std::forward_list)

erase(std::forward_list)erase_if(std::forward_list)(C++20)(C++20)



operator!=operator<operator>operator<=operator>=(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)



Deduction guides (C++17)

[edit] 





void merge( forward_list& other );

 (1)

(since C++11) (constexpr since C++26)





void merge( forward_list&& other );

 (2)

(since C++11) (constexpr since C++26)





template< class Compare > 

void merge( forward_list& other, Compare comp );

 (3)

(since C++11) (constexpr since C++26)





template< class Compare > 

void merge( forward_list&& other, Compare comp );

 (4)

(since C++11) (constexpr since C++26)







Merges two sorted lists into one sorted list.



 If other refers to the same object as *this, does nothing.

 Otherwise, transfers all elements from other to *this. other is empty after the merge.



This operation is stable:



 For equivalent elements in the two lists, the elements from *this always precede the elements from other.

 The order of equivalent elements of *this and other does not change.



1,2) Equivalent to merge(other, std::less<T>())(until C++14)merge(other, std::less<>())(since C++14).

3,4) Elements are compared using comp.

 If any of the following conditions is satisfied, the behavior is undefined:

 *this or other is not sorted with respect to the comparator comp.

 get_allocator() == other.get_allocator() is false.



No iterators or references become invalidated. The pointers and references to the elements moved from *this, as well as the iterators referring to these elements, will refer to the same elements of *this, instead of other.



Contents



1 Parameters

2 Exceptions

3 Complexity

4 Example

5 Defect reports

6 See also





[edit] Parameters





 other



 -



 another container to merge





 comp



 -



 comparison function object (i.e. an object that satisfies the requirements of Compare) which returns ​true if the first argument is less than (i.e. is ordered before) the second. 

The signature of the comparison function should be equivalent to the following:

bool cmp(const Type1& a, const Type2& b);

While the signature does not need to have const&, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) Type1 and Type2 regardless of value category (thus, Type1& is not allowed, nor is Type1 unless for Type1 a move is equivalent to a copy(since C++11)).

The types Type1 and Type2 must be such that an object of type forward_list<T, Allocator>::const_iterator can be dereferenced and then implicitly converted to both of them.

​







 Type requirements





 -Compare must meet the requirements of Compare.



[edit] Exceptions

If an exception is thrown for any reason, these functions have no effect (strong exception safety guarantee). Except if the exception comes from a comparison.



[edit] Complexity

If other refers to the same object as *this, no comparisons are performed.

Otherwise, given \(\scriptsize N_1\)N1 as std::distance(begin(), end()) and \(\scriptsize N_2\)N2 as std::distance(other.begin(), other.end()):



1,2) At most \(\scriptsize N_1 + N_2 - 1\)N1+N2-1 comparisons using operator<.

3,4) At most \(\scriptsize N_1 + N_2 - 1\)N1+N2-1 applications of the comparison function comp.

[edit] Example

Run this code

#include <iostream>

#include <forward_list>

 

std::ostream& operator<<(std::ostream& ostr, const std::forward_list<int>& list)

{

    for (const int i : list)

        ostr << ' ' << i;

    return ostr;

}

 

int main()

{

    std::forward_list<int> list1 = {5, 9, 1, 3, 3};

    std::forward_list<int> list2 = {8, 7, 2, 3, 4, 4};

 

    list1.sort();

    list2.sort();

    std::cout << "list1: " << list1 << '\n';

    std::cout << "list2: " << list2 << '\n';

 

    list1.merge(list2);

    std::cout << "merged:" << list1 << '\n';

}

Output:



list1:  1 3 3 5 9

list2:  2 3 4 4 7 8

merged: 1 2 3 3 3 4 4 5 7 8 9



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 2045



C++11



O(1) node moving could not be guaranteed ifget_allocator() != other.get_allocator()



the behavior isundefined in this case





LWG 3088



C++11



the effect when *this and other referto the same object was not specifiedoperator< could misbehave for pointer elements



specified as no-opimplementation-definedstrict total order used



[edit] See also





  splice_after



  transfers elements from another forward_list  (public member function) [edit]





  merge



  merges two sorted ranges  (function template) [edit]





  inplace_merge



  merges two ordered ranges in-place  (function template) [edit]





  ranges::merge(C++20)



 merges two sorted ranges(algorithm function object)[edit]





  ranges::inplace_merge(C++20)



 merges two ordered ranges in-place(algorithm function object)[edit]









 





                    