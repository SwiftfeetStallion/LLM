deduction guides for std::map









From cppreference.com





[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::map

Member functions





map::map

map::~map             



map::operator=

map::get_allocator









Element access

map::at

map::operator[]

Iterators

map::beginmap::cbegin(C++11)

map::endmap::cend(C++11)

map::rbeginmap::crbegin(C++11)     

map::rendmap::crend(C++11)

Capacity

map::size

map::max_size

map::empty

Observers

map::key_comp

map::value_comp



Modifiers

map::clear

map::insert

map::erase

map::swap

map::extract(C++17)

map::merge(C++17)

map::insert_range(C++23)

map::insert_or_assign(C++17)

map::emplace(C++11)

map::emplace_hint(C++11)

map::try_emplace(C++17)

Lookup

map::count

map::find

map::contains(C++20)

map::equal_range

map::lower_bound

map::upper_bound





Non-member functions





operator==operator<=>(C++20)

std::swap(std::map)

erase_if(std::map)(C++20)  







operator!=operator<operator>operator<=operator>=(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)





Deduction guides (C++17)

[edit] 





 Defined in header <map>











 template< class InputIt,

          class Comp = std::less</*iter-key-t*/<InputIt>>,

          class Alloc = std::allocator</*iter-to-alloc-t*/<InputIt>> >

map( InputIt, InputIt, Comp = Comp(), Alloc = Alloc() )



    -> map</*iter-key-t*/<InputIt>, /*iter-val-t*/<InputIt>, Comp, Alloc>;

 (1) 

 (since C++17) 





template< class Key,

          class T,

          class Comp = std::less<Key>,

          class Alloc = std::allocator<std::pair<const Key, T>> >

map( std::initializer_list<std::pair<Key, T>>, Comp = Comp(), Alloc = Alloc() )



    -> map<Key, T, Comp, Alloc>;

 (2)

(since C++17)





 template< class InputIt, class Alloc >

map( InputIt, InputIt, Alloc )

    -> map</*iter-key-t*/<InputIt>, /*iter-val-t*/<InputIt>,



           std::less</*iter-key-t*/<InputIt>>, Alloc>;

 (3) 

 (since C++17) 





 template< class Key, class T, class Alloc >

map( std::initializer_list<std::pair<Key, T>>, Alloc )



    -> map<Key, T, std::less<Key>, Alloc>;

 (4) 

 (since C++17) 





template< ranges::input_range R, class Compare = std::less</*range-key-t*/<R>,

          class Alloc = std::allocator</*range-to-alloc-t*/<R>> >

map( std::from_range_t, R&&, Compare = Compare(), Alloc = Alloc() )



    -> map</*range-key-t*/<R>, range_mapped_t<R>, Compare, Alloc>;

 (5)

(since C++23)





 template< ranges::input_range R, class Alloc >

map( std::from_range_t, R&&, Alloc )

    -> map</*range-key-t*/<R>, range_mapped_t<R>,



       map std::less</*range-key-t*/<R>>, Alloc>;

 (6) 

 (since C++23) 





 Exposition-only helper type aliases









template< class InputIt >

using /*iter-val-t*/ =



    typename std::iterator_traits<InputIt>::value_type;

 

(exposition only*)





template< class InputIt >

using /*iter-key-t*/ =



    std::remove_const_t< std::tuple_element_t<0, /*iter-val-t*/<InputIt>>>;

 

(exposition only*)





template< class InputIt >

using /*iter-mapped-t*/ =



    std::tuple_element_t<1, /*iter-val-t*/<InputIt>>;

 

(exposition only*)





template< class InputIt >

using /*iter-to-alloc-t*/ =

    std::pair<std::add_const_t<tuple_element_t<0, /*iter-val-t*/<InputIt>>>,



              std::tuple_element_t<1, /*iter-val-t*/<InputIt>>>;

 

(exposition only*)





template< ranges::input_range Range >

using /*range-key-t*/ =



    std::remove_const_t<typename ranges::range_value_t<Range>::first_type>;

 

(since C++23) (exposition only*)





template< ranges::input_range Range >

using /*range-mapped-t*/ =



    typename ranges::range_value_t<Range>::second_type;

 

(since C++23) (exposition only*)





template< ranges::input_range Range >

using /*range-to-alloc-t*/ =

    std::pair<std::add_const_t<typename ranges::range_value_t<Range>::first_type>,



              typename ranges::range_value_t<Range>::second_type>;

 

(since C++23) (exposition only*)







1-4) These deduction guides are provided for map to allow deduction from an iterator range (overloads (1,3)) and std::initializer_list (overloads (2,4)).

5,6) These deduction guides are provided for map to allow deduction from a std::from_range_t tag and an input_range.

These overloads participate in overload resolution only if InputIt satisfies LegacyInputIterator, Alloc satisfies Allocator, and Comp does not satisfy Allocator.

Note: the extent to which the library determines that a type does not satisfy LegacyInputIterator is unspecified, except that as a minimum integral types do not qualify as input iterators. Likewise, the extent to which it determines that a type does not satisfy Allocator is unspecified, except that as a minimum the member type Alloc::value_type must exist and the expression std::declval<Alloc&>().allocate(std::size_t{}) must be well-formed when treated as an unevaluated operand.



[edit] Notes





Feature-test macro

Value

Std

Feature





__cpp_lib_containers_ranges

202202L

(C++23)

Ranges-aware construction and insertion; overload (5,6)



[edit] Example

Run this code

#include <map>

 

int main()

{

    // std::map m1 = {{"foo", 1}, {"bar", 2}};

        // Error: braced-init-list has no type; cannot deduce

        // pair<Key, T> from {"foo", 1} or {"bar", 2}

 

    std::map m1 = {std::pair{"foo", 2}, {"bar", 3}}; // guide #2

    std::map m2(m1.begin(), m1.end()); // guide #1

}



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 3025



C++17



initializer-list guides (2,4) take std::pair<const Key, T>



use std::pair<Key, T>







 





                    