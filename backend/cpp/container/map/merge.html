std::map[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::map

Member functions





map::map

map::~map             



map::operator=

map::get_allocator









Element access

map::at

map::operator[]

Iterators

map::beginmap::cbegin(C++11)

map::endmap::cend(C++11)

map::rbeginmap::crbegin(C++11)     

map::rendmap::crend(C++11)

Capacity

map::size

map::max_size

map::empty

Observers

map::key_comp

map::value_comp



Modifiers

map::clear

map::insert

map::erase

map::swap

map::extract(C++17)

map::merge(C++17)

map::insert_range(C++23)

map::insert_or_assign(C++17)

map::emplace(C++11)

map::emplace_hint(C++11)

map::try_emplace(C++17)

Lookup

map::count

map::find

map::contains(C++20)

map::equal_range

map::lower_bound

map::upper_bound





Non-member functions





operator==operator<=>(C++20)

std::swap(std::map)

erase_if(std::map)(C++20)  







operator!=operator<operator>operator<=operator>=(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)





Deduction guides (C++17)

[edit] 





template< class C2 >

void merge( std::map<Key, T, C2, Allocator>& source );

 (1)

(since C++17) (constexpr since C++26)





template< class C2 >

void merge( std::map<Key, T, C2, Allocator>&& source );

 (2)

(since C++17) (constexpr since C++26)





template< class C2 >

void merge( std::multimap<Key, T, C2, Allocator>& source );

 (3)

(since C++17) (constexpr since C++26)





template< class C2 >

void merge( std::multimap<Key, T, C2, Allocator>&& source );

 (4)

(since C++17) (constexpr since C++26)







Attempts to extract (“splice”) each element in source and insert it into *this using the comparison object of *this.

If there is an element in *this with key equivalent to the key of an element from source, then that element is not extracted from source.

If get_allocator() == source.get_allocator() is false, the behavior is undefined.

No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into *this, not into source.



Contents



1 Parameters

2 Exceptions

3 Complexity

4 Example

5 See also





[edit] Parameters





 source



 -



 compatible container to transfer the nodes from



 Exceptions

Does not throw unless comparison throws.



[edit] Complexity

Given \(\scriptsize S\)S as size() and \(\scriptsize N\)N as source.size():



1-4) \(\scriptsize S \cdot \log(S + N)\)S·log(S+N)

[edit] Example

Run this code

#include <iostream>

#include <map>

#include <string>

 

int main()

{

    std::map<int, std::string> ma{{1, "apple"}, {5, "pear"}, {10, "banana"}};

    std::map<int, std::string> mb{{2, "zorro"}, {4, "batman"}, {5, "X"}, {8, "alpaca"}};

    std::map<int, std::string> u;

    u.merge(ma);

    std::cout << "ma.size(): " << ma.size() << '\n';

    u.merge(mb);

    std::cout << "mb.size(): " << mb.size() << '\n';

    std::cout << "mb.at(5): " << mb.at(5) << '\n';

    for (const auto& kv : u)

        std::cout << kv.first << ", " << kv.second << '\n';

}

Output:



ma.size(): 0

mb.size(): 1

mb.at(5): X

1, apple

2, zorro

4, batman

5, pear

8, alpaca

10, banana



[edit] See also





  extract(C++17)



  extracts nodes from the container  (public member function) [edit]





  insert



  inserts elements or nodes(since C++17)  (public member function) [edit]









 





                    