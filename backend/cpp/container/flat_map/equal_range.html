std::flat_map[edit] Containers library

node-handle(C++17)

Sequence

array(C++11)

vector

vector<bool>

inplace_vector(C++26)

hive(C++26)

deque

forward_list(C++11)

list

Associative

set

multiset

map

multimap

Unordered associative

unordered_set(C++11)

unordered_multiset(C++11)

unordered_map(C++11)

unordered_multimap(C++11)

Adaptors

stack

queue

priority_queue

flat_set(C++23)

flat_multiset(C++23)

flat_map(C++23)

flat_multimap(C++23)

Views

span(C++20)

mdspan(C++23)

Tables

Iterator invalidation

Member function table

Non-member function table

[edit] std::flat_map

Member types

Member functions





flat_map::flat_map

flat_map::operator=

Element access

flat_map::at

flat_map::operator[]

Iterators

flat_map::beginflat_map::cbegin

flat_map::endflat_map::cend

flat_map::rbeginflat_map::crbegin

flat_map::rendflat_map::crend

Lookup

flat_map::count

flat_map::find

flat_map::contains

flat_map::equal_range  

flat_map::lower_bound

flat_map::upper_bound



Capacity

flat_map::size

flat_map::max_size

flat_map::empty

Modifiers

flat_map::clear

flat_map::erase

flat_map::swap

flat_map::emplace

flat_map::extract

flat_map::replace

flat_map::insert

flat_map::insert_range

flat_map::insert_or_assign

flat_map::emplace_hint

flat_map::try_emplace

Observers

flat_map::key_comp

flat_map::keys

flat_map::value_comp

flat_map::values





Non-member functions





operator==operator<=>       



swap(std::flat_map)

erase_if(std::flat_map)





Helper classes





uses_allocator<std::flat_map>





Tags





sorted_unique     



sorted_unique_t





Deduction guides

[edit] 





std::pair<iterator, iterator> equal_range( const Key& key );

 (1)

(since C++23) (constexpr since C++26)





std::pair<const_iterator, const_iterator>

    equal_range( const Key& key ) const;

 (2)

(since C++23) (constexpr since C++26)





template< class K >

std::pair<iterator, iterator> equal_range( const K& x );

 (3)

(since C++23) (constexpr since C++26)





template< class K >

std::pair<const_iterator, const_iterator>



    equal_range( const K& x ) const;

 (4)

(since C++23) (constexpr since C++26)







Returns a range containing all elements with the given key in the container. The range is defined by two iterators, one pointing to the first element that is not less than the given key and another pointing to the first element greater than the given key.

Alternatively, the first iterator may be obtained with lower_bound(), and the second with upper_bound().



1,2) Compares the keys to key.

3,4) Compares the keys to the value x.

 This overload participates in overload resolution only if Compare is transparent. It allows calling this function without constructing an instance of Key.

Contents



1 Parameters

2 Return value

3 Complexity

4 Example

5 See also





[edit] Parameters





 key



 -



 key value to compare the elements to





 x



 -



 alternative value that can be compared to Key



[edit] Return value

std::pair containing a pair of iterators defining the wanted range:



 The first iterator points to the first element not less than the given key, or end() if no such element exists.

 The second iterator points to the first element greater than the given key, or end() if no such element exists.



[edit] Complexity

Logarithmic in the size of the container.



[edit] Example

Run this code

#include <iostream>

#include <flat_map>

 

int main()

{

    const std::flat_map<int, const char*> m

    {

        {0, "zero"},

        {1, "one"},

        {2, "two"}

    };

 

    auto p = m.equal_range(1);

    for (auto& q = p.first; q != p.second; ++q)

        std::cout << "m[" << q->first << "] = " << q->second << '\n';

 

    if (p.second == m.find(2))

        std::cout << "end of equal_range (p.second) is one-past p.first\n";

    else

        std::cout << "unexpected; p.second expected to be one-past p.first\n";

 

    auto pp = m.equal_range(-1);

    if (pp.first == m.begin())

        std::cout << "pp.first is iterator to first not-less than -1\n";

    else

        std::cout << "unexpected pp.first\n";

 

    if (pp.second == m.begin())

        std::cout << "pp.second is iterator to first element greater-than -1\n";

    else

        std::cout << "unexpected pp.second\n";

 

    auto ppp = m.equal_range(3);

    if (ppp.first == m.end())

        std::cout << "ppp.first is iterator to first not-less than 3\n";

    else

        std::cout << "unexpected ppp.first\n";

 

    if (ppp.second == m.end())

        std::cout << "ppp.second is iterator to first element greater-than 3\n";

    else

        std::cout << "unexpected ppp.second\n";

}

Output:



m[1] = one

end of equal_range (p.second) is one-past p.first

pp.first is iterator to first not-less than -1

pp.second is iterator to first element greater-than -1

ppp.first is iterator to first not-less than 3

ppp.second is iterator to first element greater-than 3



[edit] See also





  find



  finds element with specific key  (public member function) [edit]





  contains



  checks if the container contains element with specific key  (public member function) [edit]





  count



  returns the number of elements matching specific key  (public member function) [edit]





  upper_bound



  returns an iterator to the first element greater than the given key  (public member function) [edit]





  lower_bound



  returns an iterator to the first element not less than the given key  (public member function) [edit]





  equal_range



  returns range of elements matching a specific key  (function template) [edit]









 





                    