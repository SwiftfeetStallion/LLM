std::ranges::views::chunk_by, std::ranges::chunk_by_view









From cppreference.com





[edit]Â Ranges library



Range access



begin

cbeginÂ 

end

cend



rbegin

crbeginÂ 

rend

crend



size

ssizeÂ 

data

cdata



reserve_hint(C++26)Â Â 

empty













Range conversions

std::from_range_tstd::from_range(C++23)(C++23)Â Â Â Â 

to(C++23)







Dangling iterator handling

dangling

borrowed_iterator_t

borrowed_subrange_t











Range primitives



range_size_trange_difference_trange_value_t

elements_of(C++23)Â Â Â Â 



iterator_tconst_iterator_tsentinel_tconst_sentinel_t(C++23)(C++23)Â Â 



range_reference_trange_const_reference_trange_rvalue_reference_trange_common_reference_t(C++23)







Range concepts



range

borrowed_rangeÂ Â 

common_range



sized_range

viewable_rangeÂ Â 

view



input_range

output_range

forward_rangeÂ Â 



bidirectional_rangeÂ Â 

random_access_range

contiguous_range



approximately_sized_range(C++26)

constant_range(C++23)











Views



view_interfaceÂ Â 



subrange















Range factories



empty_viewviews::emptyÂ Â 



single_viewviews::singleÂ Â 



basic_istream_viewviews::istreamÂ Â 



iota_viewviews::iotaÂ Â 



repeat_viewviews::repeat(C++23)(C++23)







Range adaptors



views::all_tviews::all

as_rvalue_viewviews::as_rvalue(C++23)(C++23)Â Â 

filter_viewviews::filter

transform_viewviews::transform

take_viewviews::take

take_while_viewviews::take_while

common_viewviews::common

views::counted

to_input_viewviews::to_input(C++26)(C++26)



ref_view

drop_viewviews::drop

drop_while_viewviews::drop_while

lazy_split_viewviews::lazy_split

split_viewviews::split

join_viewviews::join

join_with_viewviews::join_with(C++23)(C++23)Â Â 

concat_viewviews::concat(C++26)(C++26)

cache_latest_viewviews::cache_latest(C++26)(C++26)Â Â 



owning_view

reverse_viewviews::reverse

as_const_viewviews::as_const(C++23)(C++23)

elements_viewviews::elements

keys_viewviews::keys

values_viewviews::values

enumerate_viewviews::enumerate(C++23)(C++23)

zip_viewviews::zip(C++23)(C++23)

zip_transform_viewviews::zip_transform(C++23)(C++23)Â Â 



adjacent_viewviews::adjacent(C++23)(C++23)

views::pairwise(C++23)

adjacent_transform_viewviews::adjacent_transform(C++23)(C++23)

views::pairwise_transform(C++23)

chunk_viewviews::chunk(C++23)(C++23)

slide_viewviews::slide(C++23)(C++23)

chunk_by_viewviews::chunk_by(C++23)(C++23)

stride_viewviews::stride(C++23)(C++23)

cartesian_product_viewviews::cartesian_product(C++23)(C++23)













Range generators

std::generator(C++23)Â Â Â Â 



Range adaptor closure objects

range_adaptor_closure(C++23)Â Â Â Â 



Range adaptor objects











Helper items



copyable-boxmovable-box(until C++23)Â Â (C++23)



simple-view

non-propagating-cache













[edit]Â std::ranges::chunk_by_view

Member functions

chunk_by_view::chunk_by_view

chunk_by_view::base

chunk_by_view::pred

chunk_by_view::begin

chunk_by_view::end

chunk_by_view::find_next

chunk_by_view::find_prev

Deduction guides

Iterator

chunk_by_view::iterator::iterator

chunk_by_view::iterator::operator*

chunk_by_view::iterator::operator++chunk_by_view::iterator::operator++(int)chunk_by_view::iterator::operator--chunk_by_view::iterator::operator--(int)

operator==(chunk_by_view::iterator)

[edit]Â 





 Defined in header <ranges>











 template< ranges::forward_range V, std::indirect_binary_predicate<iterator_t<V>,

Â  Â  Â  Â  Â  ranges::iterator_t<V>> Pred >

Â  Â  requires ranges::view<V> && std::is_object_v<Pred>

class chunk_by_view



Â  Â  : public ranges::view_interface<chunk_by_view<V, Pred>>

 (1) 

 (since C++23) 





 namespace views {

Â  Â  inline constexpr /* unspecified */ chunk_by = /* unspecified */ ;



}

 (2) 

 (since C++23) 





 Call signature









 template< ranges::viewable_range R, class Pred >

Â  Â  requires /* see below */



constexpr ranges::view auto chunk_by( R&& r, Pred&& pred );

 

 (since C++23) 





 template< class Pred >

constexpr /*range adaptor closure*/ chunk_by( Pred&& pred );

 

 (since C++23) 







1) chunk_by_view is a range adaptor that takes a view and an invocable object pred (the binary predicate), and produces a view of subranges (chunks), by splitting the underlying view between each pair of adjacent elements for which pred returns false. The first element of each such pair belongs to the previous chunk, and the second element belongs to the next chunk.

2) The name views::chunk_by denotes a RangeAdaptorObject. Given a subexpression e and f, the expression views::chunk_by(e, f) is expression-equivalent to chunk_by_view(e, f).

chunk_by_view always models forward_range, and models bidirectional_range and/or common_range, if adapted view type models the corresponding concepts.

chunk_by_view never models borrowed_range or sized_range.



Contents



1 Data members

2 Member functions



2.1 Inherited from std::ranges::view_interface





3 Deduction guides

4 Nested classes

5 Notes

6 Example

7 References

8 See also





[edit] Data members





 Member



 Definition





 V base_



 the underlying view(exposition-only member object*)





 movable-box<Pred> pred_



 an object that wraps the predicate used to split the elements of base_(exposition-only member object*)





 non-propagating-cache<iterator> begin_



 an object that caches the iterator to the first element(exposition-only member object*)





[edit] Member functions





  (constructor)



  constructs a chunk_by_view  (public member function) [edit]





  base



  returns a copy of the underlying (adapted) view  (public member function) [edit]





  pred



  returns a reference to the stored predicate  (public member function) [edit]





  begin



  returns an iterator to the beginning  (public member function) [edit]





  end



  returns an iterator or a sentinel to the end  (public member function) [edit]





 find_next



 returns an iterator to the begin of the next subrange(exposition-only member function*)





 find_prev



 returns an iterator to the begin of the previous subrange(exposition-only member function*)





   Inherited from std::ranges::view_interface 





  empty



  returns whether the derived view is empty, provided only if it satisfies sized_range or forward_range  (public member function of std::ranges::view_interface<D>) [edit]





  cbegin(C++23)



  returns a constant iterator to the beginning of the range  (public member function of std::ranges::view_interface<D>) [edit]





  cend(C++23)



  returns a sentinel for the constant iterator of the range  (public member function of std::ranges::view_interface<D>) [edit]





  operator bool



  returns whether the derived view is not empty, provided only if ranges::empty is applicable to it  (public member function of std::ranges::view_interface<D>) [edit]





  front



  returns the first element in the derived view, provided if it satisfies forward_range  (public member function of std::ranges::view_interface<D>) [edit]





  back



  returns the last element in the derived view, provided only if it satisfies bidirectional_range and common_range  (public member function of std::ranges::view_interface<D>) [edit]





[edit] Deduction guides

[edit] Nested classes





 iterator



 the iterator type(exposition-only member class template*)





[edit] Notes

In order to provide the amortized constant time complexity required by the range concept, the result of begin() is cached within the chunk_by_view object. If the underlying range is modified after the first call to begin(), subsequent uses of the chunk_by_view object might have unintuitive behavior.







Feature-test macro

Value

Std

Feature





__cpp_lib_ranges_chunk_by

202202L

(C++23)

std::ranges::chunk_by_view



[edit] Example

Run this code

#include <functional>

#include <iostream>

#include <ranges>

#include <string_view>

Â 

void print_chunks(auto view, std::string_view separator = ", ")

{

    for (auto const subrange : view)

    {

        std::cout << '[';

        for (std::string_view prefix; auto const& elem : subrange)

            std::cout << prefix << elem, prefix = separator;

        std::cout << "] ";

    }

    std::cout << '\n';

}

Â 

int main()

{

    std::initializer_list v1 = {1, 2, 3, 1, 2, 3, 3, 3, 1, 2, 3};

    auto fn1 = std::ranges::less{};

    auto view1 = v1 | std::views::chunk_by(fn1);

    print_chunks(view1);

Â 

    std::initializer_list v2 = {1, 2, 3, 4, 4, 0, 2, 3, 3, 3, 2, 1};

    auto fn2 = std::ranges::not_equal_to{};

    auto view2 = v2 | std::views::chunk_by(fn2);

    print_chunks(view2);

Â 

    std::string_view v3 = "__cpp_lib_ranges_chunk_by";

    auto fn3 = [](auto x, auto y) { return not(x == '_' or y == '_'); };

    auto view3 = v3 | std::views::chunk_by(fn3);

    print_chunks(view3, "");

Â 

    std::string_view v4 = "\u007a\u00df\u6c34\u{1f34c}"; // "zÃŸæ°´ðŸŒ"

    auto fn4 = [](auto, auto ÃŸ) { return 128 == ((128 + 64) & ÃŸ); };

    auto view4 = v4 | std::views::chunk_by(fn4);

    print_chunks(view4, "");

}

Output:



[1, 2, 3] [1, 2, 3] [3] [3] [1, 2, 3] 

[1, 2, 3, 4] [4, 0, 2, 3] [3] [3, 2, 1] 

[_] [_] [cpp] [_] [lib] [_] [ranges] [_] [chunk] [_] [by]

[z] [ÃŸ] [æ°´] [ðŸŒ]



[edit] References



 C++23 standard (ISO/IEC 14882:2024): 



 26.7.30 Chunk by view [range.chunk.by] 







[edit] See also





  ranges::chunk_viewviews::chunk(C++23)



 a range of views that are N-sized non-overlapping successive chunks of the elements of another view(class template) (range adaptor object)[edit]





  ranges::slide_viewviews::slide(C++23)



 a view whose Mth element is a view over the Mth through (M + N - 1)th elements of another view(class template) (range adaptor object)[edit]





  ranges::stride_viewviews::stride(C++23)



 a view consisting of elements of another view, advancing over N elements at a time(class template) (range adaptor object)[edit]









 





                    