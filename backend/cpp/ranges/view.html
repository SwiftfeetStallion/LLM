std::ranges::view, std::ranges::enable_view, std::ranges::view_base









From cppreference.com





[edit]Â Ranges library



Range access



begin

cbeginÂ 

end

cend



rbegin

crbeginÂ 

rend

crend



size

ssizeÂ 

data

cdata



reserve_hint(C++26)Â Â 

empty













Range conversions

std::from_range_tstd::from_range(C++23)(C++23)Â Â Â Â 

to(C++23)







Dangling iterator handling

dangling

borrowed_iterator_t

borrowed_subrange_t











Range primitives



range_size_trange_difference_trange_value_t

elements_of(C++23)Â Â Â Â 



iterator_tconst_iterator_tsentinel_tconst_sentinel_t(C++23)(C++23)Â Â 



range_reference_trange_const_reference_trange_rvalue_reference_trange_common_reference_t(C++23)







Range concepts



range

borrowed_rangeÂ Â 

common_range



sized_range

viewable_rangeÂ Â 

view



input_range

output_range

forward_rangeÂ Â 



bidirectional_rangeÂ Â 

random_access_range

contiguous_range



approximately_sized_range(C++26)

constant_range(C++23)











Views



view_interfaceÂ Â 



subrange















Range factories



empty_viewviews::emptyÂ Â 



single_viewviews::singleÂ Â 



basic_istream_viewviews::istreamÂ Â 



iota_viewviews::iotaÂ Â 



repeat_viewviews::repeat(C++23)(C++23)







Range adaptors



views::all_tviews::all

as_rvalue_viewviews::as_rvalue(C++23)(C++23)Â Â 

filter_viewviews::filter

transform_viewviews::transform

take_viewviews::take

take_while_viewviews::take_while

common_viewviews::common

views::counted

to_input_viewviews::to_input(C++26)(C++26)



ref_view

drop_viewviews::drop

drop_while_viewviews::drop_while

lazy_split_viewviews::lazy_split

split_viewviews::split

join_viewviews::join

join_with_viewviews::join_with(C++23)(C++23)Â Â 

concat_viewviews::concat(C++26)(C++26)

cache_latest_viewviews::cache_latest(C++26)(C++26)Â Â 



owning_view

reverse_viewviews::reverse

as_const_viewviews::as_const(C++23)(C++23)

elements_viewviews::elements

keys_viewviews::keys

values_viewviews::values

enumerate_viewviews::enumerate(C++23)(C++23)

zip_viewviews::zip(C++23)(C++23)

zip_transform_viewviews::zip_transform(C++23)(C++23)Â Â 



adjacent_viewviews::adjacent(C++23)(C++23)

views::pairwise(C++23)

adjacent_transform_viewviews::adjacent_transform(C++23)(C++23)

views::pairwise_transform(C++23)

chunk_viewviews::chunk(C++23)(C++23)

slide_viewviews::slide(C++23)(C++23)

chunk_by_viewviews::chunk_by(C++23)(C++23)

stride_viewviews::stride(C++23)(C++23)

cartesian_product_viewviews::cartesian_product(C++23)(C++23)













Range generators

std::generator(C++23)Â Â Â Â 



Range adaptor closure objects

range_adaptor_closure(C++23)Â Â Â Â 



Range adaptor objects











Helper items



copyable-boxmovable-box(until C++23)Â Â (C++23)



simple-view

non-propagating-cache













[edit]Â 





 Defined in header <ranges>











 template<class T>

concept view = ranges::range<T> && std::movable<T> && ranges::enable_view<T>;

 (1) 

 (since C++20) 





 template<class T>

constexpr bool enable_view =



Â  Â  std::derived_from<T, view_base> || /*is-derived-from-view-interface*/<T>;

 (2) 

 (since C++20) 





 struct view_base { };

 (3) 

 (since C++20) 







1) The view concept specifies the requirements of a range type that has suitable semantic properties for use in constructing range adaptor pipelines.

2) The enable_view variable template is used to indicate whether a range is a view. /*is-derived-from-view-interface*/<T> is true if and only if T has exactly one public base class ranges::view_interface<U> for some type U, and T has no base classes of type ranges::view_interface<V> for any other type V.

Users may specialize enable_view to true for cv-unqualified program-defined types which model view, and false for types which do not. Such specializations must be usable in constant expressions and have type const bool.

3) Deriving from view_base enables range types to model view.

Contents



1 Semantic requirements

2 Specializations

3 Notes

4 Example

5 Defect reports





[edit] Semantic requirements

1) T models view only if:

 move construction of T has constant time complexity, and

 if \(\scriptsize N\)N copies and/or moves are made from a T object holding \(\scriptsize M\)M elements, then these \(\scriptsize N\)N objects have \(\scriptsize \mathcal{O}{(N+M)}\)ğ“(N+M) destruction (which implies that a moved-from view object has \(\scriptsize \mathcal{O}{(1)}\)ğ“(1) destruction), and

 either std::copy_constructible<T> is false, or copy construction of T has constant time complexity, and

 either std::copyable<T> is false, or copy assignment of T has no more time complexity than destruction followed by copy construction.



[edit] Specializations

Specializations of enable_view for all specializations of the following standard templates are defined as true:



 std::basic_string_view

 std::span







 std::optional





(since C++26)



[edit] Notes

Examples of view types are:



 A range type that wraps a pair of iterators, e.g., std::ranges::subrange<I>.

 A range type that holds its elements by std::shared_ptr and shares ownership with all its copies.

 A range type that generates its elements on demand, e.g., std::ranges::iota_view.



A copyable container such as std::vector<std::string> generally does not meet the semantic requirements of view since copying the container copies all of the elements, which cannot be done in constant time.

While views were originally described as cheaply copyable and non-owning ranges, a type is not required to be copyable or non-owning for it to model view. However, it must still be cheap to copy (if it is copyable), move, assign, and destroy, so that range adaptors will not have unexpected complexity.

By default, a type modeling movable and range is considered a view if it is publicly and unambiguously derived from view_base, or exactly one specialization of std::ranges::view_interface.



[edit] Example

A minimum view.



#include <ranges>

Â 

struct ArchetypalView : std::ranges::view_interface<ArchetypalView>

{

    int* begin();

    int* end();

};

Â 

static_assert(std::ranges::view<ArchetypalView>);

[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





P2325R3



C++20



view required default_initializable



does not require





LWG 3549



C++20



enable_view did not detect inheritance from view_interface



detects





P2415R2



C++20



the restriction on the time complexity of destruction was too strict



relaxed







 





                    