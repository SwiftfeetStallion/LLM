std::has_unique_object_representations









From cppreference.com





[edit] Metaprogramming library

Type traits



Type categories

is_void(C++11)

is_null_pointer(C++11)(DR*)



is_array(C++11)

is_pointer(C++11)

is_enum(C++11)

is_union(C++11)

is_class(C++11)

is_function(C++11)

is_reference(C++11) 



is_object(C++11)

is_scalar(C++11)

is_compound(C++11)

is_integral(C++11)

is_floating_point(C++11)  

is_fundamental(C++11)

is_arithmetic(C++11)



is_lvalue_reference(C++11)

is_rvalue_reference(C++11)

is_member_pointer(C++11)

is_member_object_pointer(C++11)

is_member_function_pointer(C++11)

Type properties

is_const(C++11)

is_volatile(C++11)

is_empty(C++11)

is_polymorphic(C++11)

is_final(C++14)

is_abstract(C++11)

is_aggregate(C++17)

is_implicit_lifetime(C++23)

is_trivial(C++11)(deprecated in C++26)

is_trivially_copyable(C++11)

is_standard_layout(C++11)

is_literal_type(C++11)(until C++20*)

is_pod(C++11)(deprecated in C++20)

is_signed(C++11)

is_unsigned(C++11)

is_bounded_array(C++20)

is_unbounded_array(C++20)

is_scoped_enum(C++23)

has_unique_object_representations(C++17)

Type trait constants

integral_constantbool_constanttrue_typefalse_type(C++11)(C++17)(C++11)(C++11)

Metafunctions

conjunction(C++17)

disjunction(C++17)

negation(C++17)



Supported operations



is_constructibleis_trivially_constructibleis_nothrow_constructible(C++11)(C++11)(C++11)

is_default_constructibleis_trivially_default_constructibleis_nothrow_default_constructible(C++11)(C++11)(C++11)

is_copy_constructibleis_trivially_copy_constructibleis_nothrow_copy_constructible(C++11)(C++11)(C++11)

is_move_constructibleis_trivially_move_constructibleis_nothrow_move_constructible(C++11)(C++11)(C++11)

is_assignableis_trivially_assignableis_nothrow_assignable(C++11)(C++11)(C++11)



is_copy_assignableis_trivially_copy_assignableis_nothrow_copy_assignable(C++11)(C++11)(C++11)

is_move_assignableis_trivially_move_assignableis_nothrow_move_assignable(C++11)(C++11)(C++11)

is_destructibleis_trivially_destructibleis_nothrow_destructible(C++11)(C++11)(C++11)

has_virtual_destructor(C++11)

is_swappable_withis_swappableis_nothrow_swappable_withis_nothrow_swappable(C++17)(C++17)(C++17)(C++17)







Relationships and property queries



is_same(C++11)

is_convertibleis_nothrow_convertible(C++11)(C++20)

is_layout_compatible(C++20)

is_pointer_interconvertible_base_of(C++20)

is_pointer_interconvertible_with_class(C++20)  

is_corresponding_member(C++20)

reference_constructs_from_temporary(C++23)

reference_converts_from_temporary(C++23)



is_base_of(C++11)

is_virtual_base_of(C++26)

alignment_of(C++11)

rank(C++11)

extent(C++11)

is_invocableis_invocable_ris_nothrow_invocableis_nothrow_invocable_r(C++17)(C++17)(C++17)(C++17)



Type modifications



remove_cvremove_constremove_volatile(C++11)(C++11)(C++11)

add_cvadd_constadd_volatile(C++11)(C++11)(C++11)

make_signed(C++11)

make_unsigned(C++11)



remove_reference(C++11)

add_lvalue_referenceadd_rvalue_reference(C++11)(C++11)

remove_pointer(C++11)

add_pointer(C++11)

remove_extent(C++11)

remove_all_extents(C++11)







Type transformations



aligned_storage(C++11)(deprecated in C++23)

aligned_union(C++11)(deprecated in C++23)

decay(C++11)

remove_cvref(C++20)

result_ofinvoke_result(C++11)(until C++20*)(C++17)







conditional(C++11)

common_type(C++11)

common_reference(C++20)

underlying_type(C++11)

type_identity(C++20)

enable_if(C++11)

void_t(C++17)





Compile-time rational arithmetic

Compile-time integer sequences

integer_sequence(C++14)

[edit] 





 Defined in header <type_traits>











 template< class T >

struct has_unique_object_representations;

 

 (since C++17) 







std::has_unique_object_representations is a UnaryTypeTrait.

If T is trivially copyable and if any two objects of type T with the same value have the same object representation, provides the member constant value equal true. For any other type, value is false.

For the purpose of this trait, two arrays have the same value if their elements have the same values, two non-union classes have the same value if their direct subobjects have the same value, and two unions have the same value if they have the same active member and the value of that member is the same.

It is implementation-defined which scalar types satisfy this trait, but unsigned(until C++20) integer types that do not use padding bits are guaranteed to have unique object representations.

If std::remove_all_extents_t<T> is an incomplete type other than (possibly cv-qualified) void, the behavior is undefined.

If the program adds specializations for std::has_unique_object_representations or std::has_unique_object_representations_v, the behavior is undefined.



Contents



1 Template parameters

2 Helper variable template

3 Inherited from  std::integral_constant



3.1 Member constants

3.2 Member functions

3.3 Member types

3.4 Notes

3.5 Example

3.6 Defect reports

3.7 See also









[edit] Template parameters





 T



 -



 a type to check



[edit] Helper variable template





 template< class T >

constexpr bool has_unique_object_representations_v =



    has_unique_object_representations<T>::value;

 

 (since C++17) 









[edit]

 Inherited from  std::integral_constant

 Member constants





 value[static]



 true if T has unique object representations, false otherwise   (public static member constant)





 Member functions





 operator bool



   converts the object to bool, returns value  (public member function)





 operator()(C++14)



   returns value  (public member function)





 Member types





  Type



  Definition





 value_type



 bool





 type



 std::integral_constant<bool, value>







[edit] Notes

This trait was introduced to make it possible to determine whether a type can be correctly hashed by hashing its object representation as a byte array.







Feature-test macro

Value

Std

Feature





__cpp_lib_has_unique_object_representations

201606L

(C++17)

std::has_unique_object_representations



[edit] Example

Run this code

#include <cstdint>

#include <type_traits>

 

struct unpadded

{

    std::uint32_t a, b;

};

 

struct likely_padded

{

    std::uint8_t c;

    std::uint16_t st;

    std::uint32_t i;

};

 

int main()

{

    // Every value of a char corresponds to exactly one object representation.

    static_assert(std::has_unique_object_representations_v<char>);

    // For IEC 559 floats, assertion passes because the value NaN has

    // multiple object representations.

    static_assert(!std::has_unique_object_representations_v<float>);

 

    // Should succeed in any sane implementation because unpadded

    // is typically not padded, and std::uint32_t cannot contain padding bits.

    static_assert(std::has_unique_object_representations_v<unpadded>);

    // Fails in most implementations because padding bits are inserted

    // between the data members c and st for the purpose of aligning st to 16 bits.

    static_assert(!std::has_unique_object_representations_v<likely_padded>);

 

    // Notable architectural divergence:

    static_assert(std::has_unique_object_representations_v<bool>);  // x86

 // static_assert(!std::has_unique_object_representations_v<bool>); // ARM

}



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 4113



C++17



T could be an array of unknown boundeven if its element type is incomplete



required the elementtype to be complete



[edit] See also





  is_standard_layout(C++11)



  checks if a type is a standard-layout type  (class template) [edit]





  hash(C++11)



  hash function object  (class template) [edit]









 





                    