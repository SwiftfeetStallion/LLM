C++ named requirements: AccessorPolicy (since C++23)









From cppreference.com





[edit] C++ named requirements



Basic

DefaultConstructible

MoveConstructible(C++11)

CopyConstructible

CopyAssignable

MoveAssignable(C++11)

Destructible

Type properties

ScalarType

PODType

TriviallyCopyable(C++11)

TrivialType(C++11)

StandardLayoutType(C++11)  

ImplicitLifetimeType

Library-wide

BooleanTestable

EqualityComparable

LessThanComparable

Swappable

ValueSwappable(C++11)

NullablePointer(C++11)

Hash(C++11)

Allocator

FunctionObject

Callable

Predicate

BinaryPredicate

Compare



















Container

Container

ReversibleContainer

AllocatorAwareContainer

SequenceContainer

ContiguousContainer(C++17)

AssociativeContainer

UnorderedAssociativeContainer(C++11)  

Container element

DefaultInsertable(C++11)

CopyInsertable(C++11)

MoveInsertable(C++11)

EmplaceConstructible(C++11)

Erasable(C++11)

Iterator

LegacyIterator

LegacyInputIterator

LegacyOutputIterator

LegacyForwardIterator

LegacyBidirectionalIterator

LegacyRandomAccessIterator

LegacyContiguousIterator(C++17)

ConstexprIterator(C++20)

Stream I/O

FormattedInputFunction

UnformattedInputFunction

FormattedOutputFunction

UnformattedOutputFunction

Formatters

BasicFormatter(C++20)

Formatter(C++20)



Random Numbers

SeedSequence(C++11)

RandomNumberEngine(C++11)

RandomNumberDistribution(C++11)

UniformRandomBitGenerator(C++11)

RandomNumberEngineAdaptor(C++11)

Concurrency

BasicLockable(C++11)

Lockable(C++11)

TimedLockable(C++11)

SharedLockable(C++14)

SharedTimedLockable(C++14)

Mutex(C++11)

TimedMutex(C++11)

SharedMutex(C++17)

SharedTimedMutex(C++14)

Ranges

RangeAdaptorObject(C++20)

RangeAdaptorClosureObject(C++20)

Multidimensional View

LayoutMapping(C++23)

LayoutMappingPolicy(C++23)

AccessorPolicy(C++23)

Other



CharTraits

RegexTraits(C++11)  

BitmaskType

LiteralType(C++11)

NumericType



UnaryTypeTrait(C++11)

BinaryTypeTrait(C++11)

TransformationTrait(C++11)

Clock(C++11)

TrivialClock(C++11)









[edit] 

AccessorPolicy defines how elements are accessed from a given data handle to such elements and an index. It is used as a policy in std::mdspan to specify the access to a reference of an element using an underlying 1D index.



Contents



1 Requirements



1.1 Legend

1.2 Member types

1.3 Member functions





2 Accessible range

3 Standard library





[edit] Requirements

A type A satisfies AccessorPolicy if it models copyable, and the following are true:



 std::is_nothrow_move_constructible_v<A>

 std::is_nothrow_move_assignable_v<A>

 std::is_nothrow_swappable_v<A>



And, given the following types and values, the expressions shown in the table below are valid and have the indicated semantics:



[edit] Legend





 Type



 Definition





 A



 an accessor policy type





 OP



 an offset policy type





 Value



 Definition





 a



 a value of type (possibly const-qualified) A





 p



 a value of type (possibly const-qualified) A::data_handle_type





 i, j, n



 values of type std::size_t





[edit] Member types





Type



Definition



Requirements





A::element_type



unspecified





 A complete object type that is not an abstract class type







A::data_handle_type



unspecified[1]





 Models copyable

 The following values are all true:



 std::is_nothrow_move_constructible_v    <typename A::data_handle_type>

 std::is_nothrow_move_assignable_v    <typename A::data_handle_type>

 std::is_nothrow_swappable_v    <typename A::data_handle_type>









A::reference



unspecified[2]





 std::common_reference_with<typename A::reference&&,                           typename A::element_type&> is true







A::offset_policy



OP





 Satisfies the requirements of AccessorPolicy

 std::constructible_from<OP, const A&> is true

 typename OP​::​element_type and typename A​::​element_type are the same type







↑ Not required to be element_type*.



↑ Not required to be element_type&.





[edit] Member functions





Expression



Return type



Semantics





a.access(p, i)



typename A::reference





 The expression is equality-preserving.







a.offset(p, i)



typename A::offset_policy          ::data_handle_type





 A value q such that for b being A::offset_policy(a), and any integer n for which [​0​, n) is an accessible range (see below) of p and a.



 [​0​, n - i) is an accessible range of q and b; and

 b.access(q, j) provides access to the same element as a.access(p, i + j), for every j in the range [​0​, n - i).





 The expression is equality-preserving.





[edit] Accessible range

A range of indices [​0​, N) is an accessible range of a given data handle and an accessor if, for each index in the range, the access member function produces a valid reference to an element.



[edit] Standard library

The following standard library types satisfy AccessorPolicy requirements:







  default_accessor(C++23)



  a type for indexed access to elements of mdspan  (class template) [edit]





  aligned_accessor(C++26)



  a type for aligned access to elements of mdspan  (class template) [edit]





 Defined in  namespace std::linalg 





  scaled_accessor(C++26)



 std::mdspan accessor policy whose reference represents the product of a scaling factor that is fixed and its nested std::mdspan accessor's reference  (class template) [edit]





  conjugated_accessor(C++26)



 std::mdspan accessor policy whose reference represents the complex conjugate of its nested std::mdspan accessor's reference  (class template) [edit]









 





                    