C++ named requirements: CustomizationPointObject (since C++20)









From cppreference.com





[edit] C++ named requirements



Basic

DefaultConstructible

MoveConstructible(C++11)

CopyConstructible

CopyAssignable

MoveAssignable(C++11)

Destructible

Type properties

ScalarType

PODType

TriviallyCopyable(C++11)

TrivialType(C++11)

StandardLayoutType(C++11)  

ImplicitLifetimeType

Library-wide

BooleanTestable

EqualityComparable

LessThanComparable

Swappable

ValueSwappable(C++11)

NullablePointer(C++11)

Hash(C++11)

Allocator

FunctionObject

Callable

Predicate

BinaryPredicate

Compare



















Container

Container

ReversibleContainer

AllocatorAwareContainer

SequenceContainer

ContiguousContainer(C++17)

AssociativeContainer

UnorderedAssociativeContainer(C++11)  

Container element

DefaultInsertable(C++11)

CopyInsertable(C++11)

MoveInsertable(C++11)

EmplaceConstructible(C++11)

Erasable(C++11)

Iterator

LegacyIterator

LegacyInputIterator

LegacyOutputIterator

LegacyForwardIterator

LegacyBidirectionalIterator

LegacyRandomAccessIterator

LegacyContiguousIterator(C++17)

ConstexprIterator(C++20)

Stream I/O

FormattedInputFunction

UnformattedInputFunction

FormattedOutputFunction

UnformattedOutputFunction

Formatters

BasicFormatter(C++20)

Formatter(C++20)



Random Numbers

SeedSequence(C++11)

RandomNumberEngine(C++11)

RandomNumberDistribution(C++11)

UniformRandomBitGenerator(C++11)

RandomNumberEngineAdaptor(C++11)

Concurrency

BasicLockable(C++11)

Lockable(C++11)

TimedLockable(C++11)

SharedLockable(C++14)

SharedTimedLockable(C++14)

Mutex(C++11)

TimedMutex(C++11)

SharedMutex(C++17)

SharedTimedMutex(C++14)

Ranges

RangeAdaptorObject(C++20)

RangeAdaptorClosureObject(C++20)

Multidimensional View

LayoutMapping(C++23)

LayoutMappingPolicy(C++23)

AccessorPolicy(C++23)

Other



CharTraits

RegexTraits(C++11)  

BitmaskType

LiteralType(C++11)

NumericType



UnaryTypeTrait(C++11)

BinaryTypeTrait(C++11)

TransformationTrait(C++11)

Clock(C++11)

TrivialClock(C++11)









[edit] 

Customization point objects are stateless function objects of a literal semiregular class type.

All customization point objects of the same class type are equal. The effects of invoking different instances of that type on the same arguments are equivalent, whether the expression denoting the instance is an lvalue or rvalue, const-qualified or not. However, a volatile-qualified instance is not required to be invocable. Thus, customization point objects can be copied freely and the copies can be used interchangeably.

Let Fn be the type of a customization point object, and Args... be a set of types, if std::declval<Args>()... meet the requirements for arguments to Fn, Fn models



 std::invocable<Fn, Args...>,

 std::invocable<const Fn, Args...>,

 std::invocable<Fn&, Args...>, and

 std::invocable<const Fn&, Args...>.



Otherwise, no function call operator of Fn participates in overload resolution.







 





                    