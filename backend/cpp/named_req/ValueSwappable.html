C++ named requirements: ValueSwappable (since C++11)









From cppreference.com





[edit] C++ named requirements



Basic

DefaultConstructible

MoveConstructible(C++11)

CopyConstructible

CopyAssignable

MoveAssignable(C++11)

Destructible

Type properties

ScalarType

PODType

TriviallyCopyable(C++11)

TrivialType(C++11)

StandardLayoutType(C++11)  

ImplicitLifetimeType

Library-wide

BooleanTestable

EqualityComparable

LessThanComparable

Swappable

ValueSwappable(C++11)

NullablePointer(C++11)

Hash(C++11)

Allocator

FunctionObject

Callable

Predicate

BinaryPredicate

Compare



















Container

Container

ReversibleContainer

AllocatorAwareContainer

SequenceContainer

ContiguousContainer(C++17)

AssociativeContainer

UnorderedAssociativeContainer(C++11)  

Container element

DefaultInsertable(C++11)

CopyInsertable(C++11)

MoveInsertable(C++11)

EmplaceConstructible(C++11)

Erasable(C++11)

Iterator

LegacyIterator

LegacyInputIterator

LegacyOutputIterator

LegacyForwardIterator

LegacyBidirectionalIterator

LegacyRandomAccessIterator

LegacyContiguousIterator(C++17)

ConstexprIterator(C++20)

Stream I/O

FormattedInputFunction

UnformattedInputFunction

FormattedOutputFunction

UnformattedOutputFunction

Formatters

BasicFormatter(C++20)

Formatter(C++20)



Random Numbers

SeedSequence(C++11)

RandomNumberEngine(C++11)

RandomNumberDistribution(C++11)

UniformRandomBitGenerator(C++11)

RandomNumberEngineAdaptor(C++11)

Concurrency

BasicLockable(C++11)

Lockable(C++11)

TimedLockable(C++11)

SharedLockable(C++14)

SharedTimedLockable(C++14)

Mutex(C++11)

TimedMutex(C++11)

SharedMutex(C++17)

SharedTimedMutex(C++14)

Ranges

RangeAdaptorObject(C++20)

RangeAdaptorClosureObject(C++20)

Multidimensional View

LayoutMapping(C++23)

LayoutMappingPolicy(C++23)

AccessorPolicy(C++23)

Other



CharTraits

RegexTraits(C++11)  

BitmaskType

LiteralType(C++11)

NumericType



UnaryTypeTrait(C++11)

BinaryTypeTrait(C++11)

TransformationTrait(C++11)

Clock(C++11)

TrivialClock(C++11)









[edit] 

Two objects of this type can be dereferenced and the resulting values can be swapped using unqualified function call swap() in the context where both std::swap and the user-defined swap()s are visible.



[edit] Requirements

A type T is ValueSwappable if



 T satisfies the LegacyIterator requirements.

 For any dereferenceable object x of type T (that is, any value other than the end iterator), *x satisfies the Swappable requirements.



Many standard library functions expect their arguments to satisfy ValueSwappable, which means that any time the standard library performs a swap, it uses the equivalent of using std::swap; swap(*iter1, *iter2);.



[edit] Example

Run this code

#include <iostream>

#include <vector>

 

class IntVector

{

    std::vector<int> v;

//  IntVector& operator=(IntVector); // not assignable (C++98 way)

public:

    IntVector& operator=(IntVector) = delete; // not assignable

    void swap(IntVector& other)

    {

        v.swap(other.v);

    }

};

 

void swap(IntVector& v1, IntVector& v2)

{

    v1.swap(v2);

}

 

int main()

{

    IntVector v1, v2;    // IntVector is Swappable, but not MoveAssignable

    IntVector* p1 = &v1;

    IntVector* p2 = &v2; // IntVector* is ValueSwappable

    std::iter_swap(p1, p2); // OK: iter_swap requires ValueSwappable

//  std::swap(v1, v2); // compiler error! std::swap requires MoveAssignable

}



[edit] See also





  indirectly_swappable(C++20)



  specifies that the values referenced by two indirectly_readable types can be swapped  (concept) [edit]









 





                    