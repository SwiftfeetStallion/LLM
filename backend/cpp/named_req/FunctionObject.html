C++ named requirements: FunctionObject









From cppreference.com





[edit] C++ named requirements



Basic

DefaultConstructible

MoveConstructible(C++11)

CopyConstructible

CopyAssignable

MoveAssignable(C++11)

Destructible

Type properties

ScalarType

PODType

TriviallyCopyable(C++11)

TrivialType(C++11)

StandardLayoutType(C++11)  

ImplicitLifetimeType

Library-wide

BooleanTestable

EqualityComparable

LessThanComparable

Swappable

ValueSwappable(C++11)

NullablePointer(C++11)

Hash(C++11)

Allocator

FunctionObject

Callable

Predicate

BinaryPredicate

Compare



















Container

Container

ReversibleContainer

AllocatorAwareContainer

SequenceContainer

ContiguousContainer(C++17)

AssociativeContainer

UnorderedAssociativeContainer(C++11)  

Container element

DefaultInsertable(C++11)

CopyInsertable(C++11)

MoveInsertable(C++11)

EmplaceConstructible(C++11)

Erasable(C++11)

Iterator

LegacyIterator

LegacyInputIterator

LegacyOutputIterator

LegacyForwardIterator

LegacyBidirectionalIterator

LegacyRandomAccessIterator

LegacyContiguousIterator(C++17)

ConstexprIterator(C++20)

Stream I/O

FormattedInputFunction

UnformattedInputFunction

FormattedOutputFunction

UnformattedOutputFunction

Formatters

BasicFormatter(C++20)

Formatter(C++20)



Random Numbers

SeedSequence(C++11)

RandomNumberEngine(C++11)

RandomNumberDistribution(C++11)

UniformRandomBitGenerator(C++11)

RandomNumberEngineAdaptor(C++11)

Concurrency

BasicLockable(C++11)

Lockable(C++11)

TimedLockable(C++11)

SharedLockable(C++14)

SharedTimedLockable(C++14)

Mutex(C++11)

TimedMutex(C++11)

SharedMutex(C++17)

SharedTimedMutex(C++14)

Ranges

RangeAdaptorObject(C++20)

RangeAdaptorClosureObject(C++20)

Multidimensional View

LayoutMapping(C++23)

LayoutMappingPolicy(C++23)

AccessorPolicy(C++23)

Other



CharTraits

RegexTraits(C++11)  

BitmaskType

LiteralType(C++11)

NumericType



UnaryTypeTrait(C++11)

BinaryTypeTrait(C++11)

TransformationTrait(C++11)

Clock(C++11)

TrivialClock(C++11)









[edit] 

A FunctionObject type is the type of an object that can be used on the left of the function call operator.



Contents



1 Requirements

2 Notes

3 Standard library

4 Example

5 See also





[edit] Requirements

The type T satisfies FunctionObject if



 The type T satisfies std::is_object, and



Given



 f, a value of type T or const T,

 args, suitable argument list, which may be empty.



The following expressions must be valid:







Expression

Requirements





f(args)



performs a function call



[edit] Notes

Functions and references to functions are not function object types, but can be used where function object types are expected due to function-to-pointer implicit conversion.



[edit] Standard library

 All pointers to functions satisfy this requirement.

 All function objects defined in <functional>.

 Some return types of functions of <functional>.



[edit] Example

Demonstrates different types of function objects.Run this code

#include <functional>

#include <iostream>

 

void foo(int x) { std::cout << "foo(" << x << ")\n"; }

void bar(int x) { std::cout << "bar(" << x << ")\n"; }

 

int main()

{

    void(*fp)(int) = foo;

    fp(1); // calls foo using the pointer to function

 

    std::invoke(fp, 2); // all FunctionObject types are Callable

 

    auto fn = std::function(foo); // see also the rest of <functional>

    fn(3);

    fn.operator()(3); // the same effect as fn(3)

 

    struct S

    {

        void operator()(int x) const { std::cout << "S::operator(" << x << ")\n"; }

    } s;

    s(4); // calls s.operator()

    s.operator()(4); // the same as s(4)

 

    auto lam = [](int x) { std::cout << "lambda(" << x << ")\n"; };

    lam(5); // calls the lambda

    lam.operator()(5); // the same as lam(5)

 

    struct T

    {

        using FP = void (*)(int);

        operator FP() const { return bar; }

    } t;

    t(6); // t is converted to a function pointer

    static_cast<void (*)(int)>(t)(6); // the same as t(6)

    t.operator T::FP()(6); // the same as t(6) 

}

Output:



foo(1)

foo(2)

foo(3)

foo(3)

S::operator(4)

S::operator(4)

lambda(5)

lambda(5)

bar(6)

bar(6)

bar(6)



[edit] See also





 Callable



 a type for which the invoke operation is defined(named requirement)









 





                    