C++ named requirements: Destructible









From cppreference.com





[edit] C++ named requirements



Basic

DefaultConstructible

MoveConstructible(C++11)

CopyConstructible

CopyAssignable

MoveAssignable(C++11)

Destructible

Type properties

ScalarType

PODType

TriviallyCopyable(C++11)

TrivialType(C++11)

StandardLayoutType(C++11)  

ImplicitLifetimeType

Library-wide

BooleanTestable

EqualityComparable

LessThanComparable

Swappable

ValueSwappable(C++11)

NullablePointer(C++11)

Hash(C++11)

Allocator

FunctionObject

Callable

Predicate

BinaryPredicate

Compare



















Container

Container

ReversibleContainer

AllocatorAwareContainer

SequenceContainer

ContiguousContainer(C++17)

AssociativeContainer

UnorderedAssociativeContainer(C++11)  

Container element

DefaultInsertable(C++11)

CopyInsertable(C++11)

MoveInsertable(C++11)

EmplaceConstructible(C++11)

Erasable(C++11)

Iterator

LegacyIterator

LegacyInputIterator

LegacyOutputIterator

LegacyForwardIterator

LegacyBidirectionalIterator

LegacyRandomAccessIterator

LegacyContiguousIterator(C++17)

ConstexprIterator(C++20)

Stream I/O

FormattedInputFunction

UnformattedInputFunction

FormattedOutputFunction

UnformattedOutputFunction

Formatters

BasicFormatter(C++20)

Formatter(C++20)



Random Numbers

SeedSequence(C++11)

RandomNumberEngine(C++11)

RandomNumberDistribution(C++11)

UniformRandomBitGenerator(C++11)

RandomNumberEngineAdaptor(C++11)

Concurrency

BasicLockable(C++11)

Lockable(C++11)

TimedLockable(C++11)

SharedLockable(C++14)

SharedTimedLockable(C++14)

Mutex(C++11)

TimedMutex(C++11)

SharedMutex(C++17)

SharedTimedMutex(C++14)

Ranges

RangeAdaptorObject(C++20)

RangeAdaptorClosureObject(C++20)

Multidimensional View

LayoutMapping(C++23)

LayoutMappingPolicy(C++23)

AccessorPolicy(C++23)

Other



CharTraits

RegexTraits(C++11)  

BitmaskType

LiteralType(C++11)

NumericType



UnaryTypeTrait(C++11)

BinaryTypeTrait(C++11)

TransformationTrait(C++11)

Clock(C++11)

TrivialClock(C++11)









[edit] 

Specifies that an instance of the type can be destructed.



[edit] Requirements

The type T satisfies Destructible if

Given



 u, an expression of type T.



The following expressions must be valid and have their specified effects.







Expression

Post-conditions





u.~T()



All resources owned by u are reclaimed, no exceptions are thrown.



[edit] Notes

Destructors are called implicitly at the end of object lifetime such as when leaving scope or by the delete-expression. Explicit destructor call as shown in the type requirement table is rare.

Thanks to pseudo destructor call, all scalar types meet the requirement of Destructible, while array types and reference types do not. Note that std::is_destructible allows arrays and reference types.



[edit] See also





  is_destructibleis_trivially_destructibleis_nothrow_destructible(C++11)(C++11)(C++11)



   checks if a type has a non-deleted destructor   (class template) [edit]





  destructible(C++20)



  specifies that an object of the type can be destroyed  (concept) [edit]









 





                    