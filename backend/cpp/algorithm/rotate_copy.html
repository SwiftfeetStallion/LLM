std::rotate_copy









From cppreference.com





[edit] Algorithm library

Constrained algorithms and algorithms on ranges (C++20)

Constrained algorithms, e.g. ranges::copy, ranges::sort, ...

Execution policies (C++17)





is_execution_policy(C++17)  



execution::seqexecution::parexecution::par_unseqexecution::unseq(C++17)    (C++17)(C++17)(C++20)







execution::sequenced_policyexecution::parallel_policyexecution::parallel_unsequenced_policyexecution::parallel_unsequenced(C++17)(C++17)(C++17)(C++20)







Non-modifying sequence operations

Batch operations



for_each



for_each_n(C++17)



Search operations



all_ofany_ofnone_of(C++11)                (C++11)(C++11)

countcount_if

mismatch

equal







findfind_iffind_if_not(C++11)

find_end

find_first_of

adjacent_find

search

search_n



Modifying sequence operations

Copy operations



copycopy_if(C++11)

copy_backward



copy_n(C++11)

move(C++11)

move_backward(C++11)



Swap operations



swap

iter_swap



swap_ranges







Transformation operations



replacereplace_if

transform



replace_copyreplace_copy_if







Generation operations



fill

fill_n



generate

generate_n



Removing operations



removeremove_if

unique



remove_copyremove_copy_if

unique_copy



Order-changing operations



reverse

reverse_copy

rotate

rotate_copy



random_shuffleshuffle(until C++17)(C++11)

shift_leftshift_right(C++20)(C++20)



Sampling operations



sample(C++17)











Sorting and related operations

Partitioning operations



partition

partition_copy(C++11)  

stable_partition



is_partitioned(C++11)

partition_point(C++11)







Sorting operations



sort

stable_sort

partial_sort

partial_sort_copy



is_sorted(C++11)

is_sorted_until(C++11)

nth_element







Binary search operations(on partitioned ranges)



lower_bound

upper_bound



equal_range

binary_search



Set operations (on sorted ranges)



includes

set_union

set_intersection



set_difference

set_symmetric_difference







Merge operations (on sorted ranges)



merge



inplace_merge



Heap operations



push_heap

pop_heap

make_heap



sort_heap

is_heap(C++11)

is_heap_until(C++11)



Minimum/maximum operations



max

min

minmax(C++11)

clamp(C++17)



max_element

min_element

minmax_element(C++11)







Lexicographical comparison operations

lexicographical_compare

lexicographical_compare_three_way(C++20)

Permutation operations



next_permutation

prev_permutation







is_permutation(C++11)











C library



qsort



bsearch





Numeric operations





iota(C++11)

inner_product

adjacent_difference  



accumulate

reduce(C++17)

transform_reduce(C++17)







partial_sum

inclusive_scan(C++17)   

exclusive_scan(C++17)



transform_inclusive_scan(C++17)

transform_exclusive_scan(C++17)









Operations on uninitialized memory





uninitialized_copy

uninitialized_move(C++17)   

uninitialized_fill







uninitialized_copy_n(C++11)

uninitialized_move_n(C++17)

uninitialized_fill_n











destroy(C++17)

destroy_n(C++17)

destroy_at(C++17)

construct_at(C++20)      



uninitialized_default_construct(C++17)

uninitialized_value_construct(C++17)

uninitialized_default_construct_n(C++17)

uninitialized_value_construct_n(C++17)





[edit] 





 Defined in header <algorithm>











 template< class ForwardIt, class OutputIt >

OutputIt rotate_copy( ForwardIt first, ForwardIt middle,



                      ForwardIt last, OutputIt d_first );

 (1) 

 (constexpr since C++20) 





 template< class ExecutionPolicy,

          class ForwardIt1, class ForwardIt2 >

ForwardIt2 rotate_copy( ExecutionPolicy&& policy,

                        ForwardIt1 first, ForwardIt1 middle,



                        ForwardIt1 last, ForwardIt2 d_first );

 (2) 

 (since C++17) 







Copies the left rotation of [first, last) to d_first.



1) Copies the elements from the range [first, last), such that in the destination range beginning at d_first, the elements in [first, middle) are placed after the elements in [middle, last) while the orders of the elements in both ranges are preserved.

2) Same as (1), but executed according to policy.

 This overload participates in overload resolution only if all following conditions are satisfied:





std::is_execution_policy_v<std::decay_t<ExecutionPolicy>> is true.





(until C++20)



std::is_execution_policy_v<std::remove_cvref_t<ExecutionPolicy>> is true.





(since C++20)



If any of the following conditions is satisfied, the behavior is undefined:



 [first, middle) or [middle, last) is not a valid range.

 The source and destination ranges overlap.



Contents



1 Parameters

2 Return value

3 Complexity

4 Exceptions

5 Possible implementation

6 Example

7 See also





[edit] Parameters





 first, last



 -



 the pair of iterators defining the source range of elements to copy





 middle



 -



 an iterator to an element in [first, last) that should appear at the beginning of the new range





 d_first



 -



 beginning of the destination range





 policy



 -



 the execution policy to use





 Type requirements





 -ForwardIt, ForwardIt1, ForwardIt2 must meet the requirements of LegacyForwardIterator.





 -OutputIt must meet the requirements of LegacyOutputIterator.



[edit] Return value

Output iterator to the element past the last element copied.



[edit] Complexity

Exactly std::distance(first, last) assignments.



[edit] Exceptions

The overload with a template parameter named ExecutionPolicy reports errors as follows:



 If execution of a function invoked as part of the algorithm throws an exception and ExecutionPolicy is one of the standard policies, std::terminate is called. For any other ExecutionPolicy, the behavior is implementation-defined.

 If the algorithm fails to allocate memory, std::bad_alloc is thrown.



[edit] Possible implementation

See also the implementations in libstdc++, libc++, and MSVC STL.









template<class ForwardIt, class OutputIt>

constexpr // since C++20

OutputIt rotate_copy(ForwardIt first, ForwardIt middle,

                     ForwardIt last, OutputIt d_first)

{

    d_first = std::copy(middle, last, d_first);

    return std::copy(first, middle, d_first);

}



[edit] Example

Run this code

#include <algorithm>

#include <iostream>

#include <iterator>

#include <vector>

 

int main()

{

    std::vector<int> src{1, 2, 3, 4, 5};

    std::vector<int> dest(src.size());

    auto pivot = std::find(src.begin(), src.end(), 3);

 

    std::rotate_copy(src.begin(), pivot, src.end(), dest.begin());

    for (int i : dest)

        std::cout << i << ' ';

    std::cout << '\n';

 

    // copy the rotation result directly to the std::cout

    pivot = std::find(dest.begin(), dest.end(), 1);

    std::rotate_copy(dest.begin(), pivot, dest.end(),

                     std::ostream_iterator<int>(std::cout, " "));

    std::cout << '\n';

}

Output:



3 4 5 1 2

1 2 3 4 5



[edit] See also





  rotate



  rotates the order of elements in a range  (function template) [edit]





  ranges::rotate_copy(C++20)



 copies and rotate a range of elements(algorithm function object)[edit]









 





                    