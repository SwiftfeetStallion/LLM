std::ranges::sort









From cppreference.com





[edit]Â Algorithm library

Constrained algorithms and algorithms on ranges (C++20)

Constrained algorithms, e.g. ranges::copy, ranges::sort, ...

Execution policies (C++17)





is_execution_policy(C++17)Â Â 



execution::seqexecution::parexecution::par_unseqexecution::unseq(C++17)Â Â Â Â (C++17)(C++17)(C++20)







execution::sequenced_policyexecution::parallel_policyexecution::parallel_unsequenced_policyexecution::parallel_unsequenced(C++17)(C++17)(C++17)(C++20)







Non-modifying sequence operations

Batch operations



for_each



for_each_n(C++17)



Search operations



all_ofany_ofnone_of(C++11)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (C++11)(C++11)

countcount_if

mismatch

equal







findfind_iffind_if_not(C++11)

find_end

find_first_of

adjacent_find

search

search_n



Modifying sequence operations

Copy operations



copycopy_if(C++11)

copy_backward



copy_n(C++11)

move(C++11)

move_backward(C++11)



Swap operations



swap

iter_swap



swap_ranges







Transformation operations



replacereplace_if

transform



replace_copyreplace_copy_if







Generation operations



fill

fill_n



generate

generate_n



Removing operations



removeremove_if

unique



remove_copyremove_copy_if

unique_copy



Order-changing operations



reverse

reverse_copy

rotate

rotate_copy



random_shuffleshuffle(until C++17)(C++11)

shift_leftshift_right(C++20)(C++20)



Sampling operations



sample(C++17)











Sorting and related operations

Partitioning operations



partition

partition_copy(C++11)Â Â 

stable_partition



is_partitioned(C++11)

partition_point(C++11)







Sorting operations



sort

stable_sort

partial_sort

partial_sort_copy



is_sorted(C++11)

is_sorted_until(C++11)

nth_element







Binary search operations(on partitioned ranges)



lower_bound

upper_bound



equal_range

binary_search



Set operations (on sorted ranges)



includes

set_union

set_intersection



set_difference

set_symmetric_difference







Merge operations (on sorted ranges)



merge



inplace_merge



Heap operations



push_heap

pop_heap

make_heap



sort_heap

is_heap(C++11)

is_heap_until(C++11)



Minimum/maximum operations



max

min

minmax(C++11)

clamp(C++17)



max_element

min_element

minmax_element(C++11)







Lexicographical comparison operations

lexicographical_compare

lexicographical_compare_three_way(C++20)

Permutation operations



next_permutation

prev_permutation







is_permutation(C++11)











C library



qsort



bsearch





Numeric operations





iota(C++11)

inner_product

adjacent_differenceÂ Â 



accumulate

reduce(C++17)

transform_reduce(C++17)







partial_sum

inclusive_scan(C++17)Â Â Â 

exclusive_scan(C++17)



transform_inclusive_scan(C++17)

transform_exclusive_scan(C++17)









Operations on uninitialized memory





uninitialized_copy

uninitialized_move(C++17)Â Â Â 

uninitialized_fill







uninitialized_copy_n(C++11)

uninitialized_move_n(C++17)

uninitialized_fill_n











destroy(C++17)

destroy_n(C++17)

destroy_at(C++17)

construct_at(C++20)Â Â Â Â Â Â 



uninitialized_default_construct(C++17)

uninitialized_value_construct(C++17)

uninitialized_default_construct_n(C++17)

uninitialized_value_construct_n(C++17)





[edit]Â Constrained algorithmsAll names in this menu belong to namespace std::ranges



Non-modifying sequence operations





all_ofany_ofnone_of

for_each

for_each_nÂ Â 

countcount_if



adjacent_find

mismatch

equal

lexicographical_compareÂ Â 

containscontains_subrange(C++23)(C++23)







findfind_iffind_if_not

find_lastfind_last_iffind_last_if_not(C++23)(C++23)(C++23)Â Â 







find_end

find_first_of

search

search_n

starts_with(C++23)

ends_with(C++23)









Modifying sequence operations





copycopy_if

copy_n

copy_backwardÂ Â 

move

move_backward



shift_leftshift_right(C++23)(C++23)Â Â 

fill

fill_n

generate

generate_nÂ Â 



transform

swap_rangesÂ Â 

shuffle

sample

removeremove_if



replacereplace_if

reverse

rotate

remove_copyremove_copy_ifÂ Â 



unique

replace_copyreplace_copy_if

reverse_copy

rotate_copy

unique_copy





Partitioning operations





is_partitionedÂ Â 



partition_pointÂ Â 



partitionÂ Â 



partition_copyÂ Â 



stable_partition





Sorting operations





is_sorted

is_sorted_untilÂ Â Â 



sort

stable_sortÂ Â Â Â Â Â Â 



partial_sortÂ Â Â Â Â 

nth_element



partial_sort_copy









Binary search operations (on sorted ranges)





lower_boundÂ Â Â Â Â Â Â 



upper_boundÂ Â Â Â Â Â Â 



binary_searchÂ Â Â Â 



equal_range





Set operations (on sorted ranges)





merge

inplace_mergeÂ Â Â Â Â 



set_difference

set_intersectionÂ Â 



set_unionÂ Â Â Â Â Â Â Â 

includes



set_symmetric_difference









Heap operations





is_heap

is_heap_untilÂ Â Â Â Â 



make_heapÂ Â Â Â Â Â Â Â Â 

sort_heap



push_heap

pop_heap





Minimum/maximum operations





max

max_elementÂ Â Â Â Â Â Â 



min

min_elementÂ Â Â Â Â Â Â 



minmax

minmax_elementÂ Â Â 



clamp









Permutation operations





is_permutationÂ Â Â Â 



next_permutationÂ Â 



prev_permutation





Fold operations





fold_left(C++23)

fold_left_first(C++23)Â Â 



fold_right(C++23)

fold_right_last(C++23)Â Â 



fold_left_with_iter(C++23)

fold_left_first_with_iter(C++23)









Numeric operations



iota(C++23)Â Â Â Â Â Â Â Â Â Â Â Â 





Random number generation



generate_random(C++26)







Operations on uninitialized storage





construct_atÂ Â 

destroy

destroy_n

destroy_at



uninitialized_copyÂ Â 

uninitialized_move

uninitialized_fill







uninitialized_copy_nÂ Â 

uninitialized_move_n

uninitialized_fill_n







uninitialized_default_construct

uninitialized_default_construct_n

uninitialized_value_construct

uninitialized_value_construct_n





Return types





in_fun_result

in_in_result

in_found_resultÂ Â 



in_out_result

in_in_out_resultÂ Â 







in_out_out_resultÂ Â 

min_max_result







out_value_result(C++23)

in_value_result(C++23)









[edit]Â 





 Defined in header <algorithm>











 Call signature









 template< std::random_access_iterator I, std::sentinel_for<I> S,

Â  Â  Â  Â  Â  class Comp = ranges::less, class Proj = std::identity >

requires std::sortable<I, Comp, Proj>

constexpr I 



Â  Â  sort( I first, S last, Comp comp = {}, Proj proj = {} );

 (1) 

 (since C++20) 





 template< ranges::random_access_range R, class Comp = ranges::less,

Â  Â  Â  Â  Â  class Proj = std::identity >

requires std::sortable<ranges::iterator_t<R>, Comp, Proj>

constexpr ranges::borrowed_iterator_t<R>



Â  Â  sort( R&& r, Comp comp = {}, Proj proj = {} );

 (2) 

 (since C++20) 







Sorts the elements in the range [first,Â last) in non-descending order. The order of equivalent elements is not guaranteed to be preserved.

A sequence is sorted with respect to a comparator comp if for any iterator it pointing to the sequence and any non-negative integer n such that it + n is a valid iterator pointing to an element of the sequence, std::invoke(comp, std::invoke(proj, *(it + n)), std::invoke(proj, *it)) evaluates to false.



1) Elements are compared using the given binary comparison function comp.

2) Same as (1), but uses r as the source range, as if using ranges::begin(r) as first and ranges::end(r) as last.

The function-like entities described on this page are algorithm function objects (informally known as niebloids), that is:



 Explicit template argument lists cannot be specified when calling any of them.

 None of them are visible to argument-dependent lookup.

 When any of them are found by normal unqualified lookup as the name to the left of the function-call operator, argument-dependent lookup is inhibited.



Contents



1 Parameters

2 Return value

3 Complexity

4 Possible implementation

5 Notes

6 Example

7 See also





[edit] Parameters





 first, last



 -



 the iterator-sentinel pair defining the  range of elements to sort





 r



 -



 the range to sort





 comp



 -



 comparison to apply to the projected elements





 proj



 -



 projection to apply to the elements



[edit] Return value

An iterator equal to last.



[edit] Complexity

\(\scriptsize \mathcal{O}(N\cdot\log{(N)})\)ğ“(NÂ·log(N)) comparisons and projections, where N = ranges::distance(first, last).



[edit] Possible implementation

Note that typical implementations use Introsort. See also the implementation in MSVC STL and libstdc++.









struct sort_fn

{

    template<std::random_access_iterator I, std::sentinel_for<I> S,

             class Comp = ranges::less, class Proj = std::identity>

    requires std::sortable<I, Comp, Proj>

    constexpr I

        operator()(I first, S last, Comp comp = {}, Proj proj = {}) const

    {

        if (first == last)

            return first;

Â 

        I last_iter = ranges::next(first, last);

        ranges::make_heap(first, last_iter, std::ref(comp), std::ref(proj));

        ranges::sort_heap(first, last_iter, std::ref(comp), std::ref(proj));

Â 

        return last_iter;

    }

Â 

    template<ranges::random_access_range R, class Comp = ranges::less,

             class Proj = std::identity>

    requires std::sortable<ranges::iterator_t<R>, Comp, Proj>

    constexpr ranges::borrowed_iterator_t<R>

        operator()(R&& r, Comp comp = {}, Proj proj = {}) const

    {

        return (*this)(ranges::begin(r), ranges::end(r), std::move(comp), std::move(proj));

    }

};

Â 

inline constexpr sort_fn sort {};



[edit] Notes

std::sort uses std::iter_swap to swap elements, whereas ranges::sort instead uses ranges::iter_swap (which performs ADL for iter_swap, unlike std::iter_swap)



[edit] Example

Run this code

#include <algorithm>

#include <array>

#include <functional>

#include <iomanip>

#include <iostream>

Â 

void print(auto comment, auto const& seq, char term = ' ')

{

    for (std::cout << comment << '\n'; auto const& elem : seq)

        std::cout << elem << term;

    std::cout << '\n';

}

Â 

struct Particle

{

    std::string name; double mass; // MeV

    template<class Os> friend

    Os& operator<<(Os& os, Particle const& p)

    {

        return os << std::left << std::setw(8) << p.name << "Â : " << p.mass << ' ';

    }

};

Â 

int main()

{

    std::array s {5, 7, 4, 2, 8, 6, 1, 9, 0, 3};

Â 

    namespace ranges = std::ranges;

Â 

    ranges::sort(s);

    print("Sort using the default operator<", s);

Â 

    ranges::sort(s, ranges::greater());

    print("Sort using a standard library compare function object", s);

Â 

    struct

    {

        bool operator()(int a, int b) const { return a < b; }

    } customLess;

    ranges::sort(s.begin(), s.end(), customLess);

    print("Sort using a custom function object", s);

Â 

    ranges::sort(s, [](int a, int b) { return a > b; });

    print("Sort using a lambda expression", s);

Â 

    Particle particles[]

    {

        {"Electron", 0.511}, {"Muon", 105.66}, {"Tau", 1776.86},

        {"Positron", 0.511}, {"Proton", 938.27}, {"Neutron", 939.57}

    };

    ranges::sort(particles, {}, &Particle::name);

    print("\nSort by name using a projection", particles, '\n');

    ranges::sort(particles, {}, &Particle::mass);

    print("Sort by mass using a projection", particles, '\n');

}

Output:



Sort using the default operator<

0 1 2 3 4 5 6 7 8 9

Sort using a standard library compare function object

9 8 7 6 5 4 3 2 1 0

Sort using a custom function object

0 1 2 3 4 5 6 7 8 9

Sort using a lambda expression

9 8 7 6 5 4 3 2 1 0

Â 

Sort by name using a projection

ElectronÂ : 0.511

Muon    Â : 105.66

Neutron Â : 939.57

PositronÂ : 0.511

Proton  Â : 938.27

Tau     Â : 1776.86

Â 

Sort by mass using a projection

ElectronÂ : 0.511

PositronÂ : 0.511

Muon    Â : 105.66

Proton  Â : 938.27

Neutron Â : 939.57

Tau     Â : 1776.86



[edit] See also





  ranges::partial_sort(C++20)



 sorts the first N elements of a range(algorithm function object)[edit]





  ranges::stable_sort(C++20)



 sorts a range of elements while preserving order between equal elements(algorithm function object)[edit]





  ranges::partition(C++20)



 divides a range of elements into two groups(algorithm function object)[edit]





  sort



  sorts a range into ascending order  (function template) [edit]









 





                    