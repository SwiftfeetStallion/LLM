std::unique_ptr[edit] Memory management library



voidify(exposition only*)

Allocators



allocator

allocator_traits(C++11)

allocation_result(C++23)

scoped_allocator_adaptor(C++11)

pmr::polymorphic_allocator(C++17)



allocator_arg(C++11)

uses_allocator(C++11)

uses_allocator_construction_args(C++20)

make_obj_using_allocator(C++20)

uninitialized_construct_using_allocator(C++20)



Uninitialized memory algorithms



uninitialized_copy

uninitialized_fill

uninitialized_move(C++17)

uninitialized_copy_n(C++11)

uninitialized_fill_n

uninitialized_move_n(C++17)

construct_at(C++20)



uninitialized_default_construct(C++17)

uninitialized_value_construct(C++17)

destroy(C++17)

uninitialized_default_construct_n(C++17)

uninitialized_value_construct_n(C++17)

destroy_n(C++17)

destroy_at(C++17)



Constrained uninitialized memory algorithms



ranges::uninitialized_copy(C++20)

ranges::uninitialized_fill(C++20)

ranges::uninitialized_move(C++20)

ranges::uninitialized_copy_n(C++20) 

ranges::uninitialized_fill_n(C++20)

ranges::uninitialized_move_n(C++20)

ranges::construct_at(C++20)



ranges::uninitialized_default_construct(C++20)

ranges::uninitialized_value_construct(C++20)

ranges::destroy(C++20)

ranges::uninitialized_default_construct_n(C++20) 

ranges::uninitialized_value_construct_n(C++20)

ranges::destroy_n(C++20)

ranges::destroy_at(C++20)



Memory resources



pmr::memory_resource(C++17)

pmr::get_default_resource(C++17)

pmr::set_default_resource(C++17)

pmr::new_delete_resource(C++17)

pmr::pool_options(C++17)



pmr::null_memory_resource(C++17)

pmr::synchronized_pool_resource(C++17)

pmr::unsynchronized_pool_resource(C++17)

pmr::monotonic_buffer_resource(C++17)









Explicit lifetime management

start_lifetime_as(C++23)

start_lifetime_as_array(C++23)



Types for composite class design

indirect(C++26)

polymorphic(C++26)



Uninitialized storage (until C++20)



raw_storage_iterator(until C++20*)

get_temporary_buffer(until C++20*)



return_temporary_buffer(until C++20*)







Garbage collector support (until C++23)



declare_reachable(C++11)(until C++23)

declare_no_pointers(C++11)(until C++23)

pointer_safety(C++11)(until C++23)



undeclare_reachable(C++11)(until C++23)

undeclare_no_pointers(C++11)(until C++23)

get_pointer_safety(C++11)(until C++23)





Low level memorymanagement

operator newoperator new[]

operator deleteoperator delete[]

nothrow_t

nothrow

new_handler

set_new_handler

get_new_handler(C++11)

bad_alloc

bad_array_new_length(C++11)

align_val_t(C++17)

destroying_delete_t(C++20)

launder(C++17)

Smart pointers

unique_ptr(C++11)

shared_ptr(C++11)

weak_ptr(C++11)

auto_ptr(until C++17*)

owner_less(C++11)

owner_less<void>(C++17)

owner_hash(C++26)

owner_equal(C++26)

enable_shared_from_this(C++11)

bad_weak_ptr(C++11)

default_delete(C++11)

out_ptr_t(C++23)

inout_ptr_t(C++23)

Miscellaneous

pointer_traits(C++11)

to_address(C++20)

addressof(C++11)

align(C++11)

assume_aligned(C++20)

is_sufficiently_aligned(C++26)

C Library



malloc

calloc

realloc



free

aligned_alloc(C++17)









[edit] std::unique_ptr

Member functions

unique_ptr::unique_ptr

unique_ptr::~unique_ptr

unique_ptr::operator=

Modifiers

unique_ptr::release

unique_ptr::reset

unique_ptr::swap

Observers

unique_ptr::get

unique_ptr::get_deleter

unique_ptr::operator bool

unique_ptr::operator*unique_ptr::operator->

unique_ptr::operator[]

Non-member functions

make_uniquemake_unique_for_overwrite(C++14)(C++20)

operator==operator!=operator<operator>operator<=operator>=operator<=>(until C++20)(C++20)

operator<<(C++20)

swap(std::unique_ptr)

Helper classes

hash<std::unique_ptr>

[edit] 





unique_ptr& operator=( unique_ptr&& r ) noexcept;

 (1)

(constexpr since C++23)





template< class U, class E >

unique_ptr& operator=( unique_ptr<U, E>&& r ) noexcept;

 (2)

(constexpr since C++23)





unique_ptr& operator=( std::nullptr_t ) noexcept;

 (3)

(constexpr since C++23)





 unique_ptr& operator=( const unique_ptr& ) = delete;

 (4) 

 





1) Move assignment operator. Transfers ownership from r to *this as if by calling reset(r.release()) followed by assigning get_deleter() from std::forward<Deleter>(r.get_deleter()).

 This overload participates in overload resolution only if std::is_move_assignable<Deleter>::value is true.

 If Deleter is not a reference type, the behavior is undefined if

 Deleter is not MoveAssignable, or

 assigning get_deleter() from an rvalue of type Deleter would throw an exception.



 Otherwise (Deleter is a reference type), the behavior is undefined if

 std::remove_reference<Deleter>::type is not CopyAssignable, or

 assigning get_deleter() from an lvalue of type Deleter would throw an exception.



2) Converting assignment operator. Transfers ownership from r to *this as if by calling reset(r.release()) followed by assigning get_deleter() from std::forward<E>(r.get_deleter()).

 This overload participates in overload resolution only if all following conditions are satisfied:

 std::is_assignable<Deleter&, E&&>::value is true.

 For the primary template, all following conditions are satisfied:

 U is not an array type.

 unique_ptr<U, E>::pointer is implicitly convertible to pointer, and.



 For the array specialization (unique_ptr<T[]>), all following conditions are satisfied:

 U is an array type.

 pointer is the same type as element_type*.

 unique_ptr<U, E>::pointer is the same type as unique_ptr<U, E>::element_type*.

 unique_ptr<U, E>::element_type(*)[] is convertible to element_type(*)[].





 If E is not a reference type, the behavior is undefined if assigning get_deleter() from an rvalue of type E is ill-formed or would throw an exception.

 Otherwise (E is a reference type), the behavior is undefined if assigning get_deleter() from an lvalue of type E is ill-formed or would throw an exception.

3) Effectively the same as calling reset().

4) Copy assignment operator is explicitly deleted.

Contents



1 Parameters

2 Return value

3 Notes

4 Example

5 Defect reports





[edit] Parameters





 r



 -



 smart pointer from which ownership will be transferred



[edit] Return value

*this



[edit] Notes

As a move-only type, unique_ptr's assignment operator only accepts rvalues arguments (e.g. the result of std::make_unique or a std::move'd unique_ptr variable).



[edit] Example

Run this code

#include <iostream>

#include <memory>

 

struct Foo

{

    int id;

    Foo(int id) : id(id) { std::cout << "Foo " << id << '\n'; }

    ~Foo() { std::cout << "~Foo " << id << '\n'; }

};

 

int main() 

{

    std::unique_ptr<Foo> p1(std::make_unique<Foo>(1));

 

    {

        std::cout << "Creating new Foo...\n";

        std::unique_ptr<Foo> p2(std::make_unique<Foo>(2));

        // p1 = p2; // Error ! can't copy unique_ptr

        p1 = std::move(p2);

        std::cout << "About to leave inner block...\n";

 

        // Foo instance will continue to live, 

        // despite p2 going out of scope

    }

 

    std::cout << "About to leave program...\n";

}

Output:



Foo 1

Creating new Foo...

Foo 2

~Foo 1

About to leave inner block...

About to leave program...

~Foo 2



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 2047



C++11



for overload (2), get_deleter() was assigned fromstd::forward<Deleter>(r.get_deleter())



corrected tostd::forward<E>(r.get_deleter())





LWG 2118



C++11



unique_ptr<T[]>::operator=rejected qualification conversions



accepts





LWG 2228(N4366)



C++11



the converting assignment operatorwas missing the assignability constraint



added the constraint





LWG 2246



C++11



the assignment target of the converteddeleter of r was not specified



specified as get_deleter()





LWG 2899



C++11



the move assignment operator was not constrained



constrained







 





                    