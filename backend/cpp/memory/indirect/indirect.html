std::indirect[edit] Memory management library



voidify(exposition only*)

Allocators



allocator

allocator_traits(C++11)

allocation_result(C++23)

scoped_allocator_adaptor(C++11)

pmr::polymorphic_allocator(C++17)



allocator_arg(C++11)

uses_allocator(C++11)

uses_allocator_construction_args(C++20)

make_obj_using_allocator(C++20)

uninitialized_construct_using_allocator(C++20)



Uninitialized memory algorithms



uninitialized_copy

uninitialized_fill

uninitialized_move(C++17)

uninitialized_copy_n(C++11)

uninitialized_fill_n

uninitialized_move_n(C++17)

construct_at(C++20)



uninitialized_default_construct(C++17)

uninitialized_value_construct(C++17)

destroy(C++17)

uninitialized_default_construct_n(C++17)

uninitialized_value_construct_n(C++17)

destroy_n(C++17)

destroy_at(C++17)



Constrained uninitialized memory algorithms



ranges::uninitialized_copy(C++20)

ranges::uninitialized_fill(C++20)

ranges::uninitialized_move(C++20)

ranges::uninitialized_copy_n(C++20) 

ranges::uninitialized_fill_n(C++20)

ranges::uninitialized_move_n(C++20)

ranges::construct_at(C++20)



ranges::uninitialized_default_construct(C++20)

ranges::uninitialized_value_construct(C++20)

ranges::destroy(C++20)

ranges::uninitialized_default_construct_n(C++20) 

ranges::uninitialized_value_construct_n(C++20)

ranges::destroy_n(C++20)

ranges::destroy_at(C++20)



Memory resources



pmr::memory_resource(C++17)

pmr::get_default_resource(C++17)

pmr::set_default_resource(C++17)

pmr::new_delete_resource(C++17)

pmr::pool_options(C++17)



pmr::null_memory_resource(C++17)

pmr::synchronized_pool_resource(C++17)

pmr::unsynchronized_pool_resource(C++17)

pmr::monotonic_buffer_resource(C++17)









Explicit lifetime management

start_lifetime_as(C++23)

start_lifetime_as_array(C++23)



Types for composite class design

indirect(C++26)

polymorphic(C++26)



Uninitialized storage (until C++20)



raw_storage_iterator(until C++20*)

get_temporary_buffer(until C++20*)



return_temporary_buffer(until C++20*)







Garbage collector support (until C++23)



declare_reachable(C++11)(until C++23)

declare_no_pointers(C++11)(until C++23)

pointer_safety(C++11)(until C++23)



undeclare_reachable(C++11)(until C++23)

undeclare_no_pointers(C++11)(until C++23)

get_pointer_safety(C++11)(until C++23)





Low level memorymanagement

operator newoperator new[]

operator deleteoperator delete[]

nothrow_t

nothrow

new_handler

set_new_handler

get_new_handler(C++11)

bad_alloc

bad_array_new_length(C++11)

align_val_t(C++17)

destroying_delete_t(C++20)

launder(C++17)

Smart pointers

unique_ptr(C++11)

shared_ptr(C++11)

weak_ptr(C++11)

auto_ptr(until C++17*)

owner_less(C++11)

owner_less<void>(C++17)

owner_hash(C++26)

owner_equal(C++26)

enable_shared_from_this(C++11)

bad_weak_ptr(C++11)

default_delete(C++11)

out_ptr_t(C++23)

inout_ptr_t(C++23)

Miscellaneous

pointer_traits(C++11)

to_address(C++20)

addressof(C++11)

align(C++11)

assume_aligned(C++20)

is_sufficiently_aligned(C++26)

C Library



malloc

calloc

realloc



free

aligned_alloc(C++17)









[edit] std::indirect

Member functions

indirect::indirect

indirect::~indirect

indirect::operator=

Observers

indirect::operator->indirect::operator*

indirect::valueless_after_move

indirect::get_allocator

Modifiers

indirect::swap

Non-member functions

operator==operator<=>

swap(std::indirect)

Deduction guides

Helper classes

hash<std::indirect>

[edit] 





constexpr explicit indirect();

 (1)

(since C++26)





constexpr explicit indirect( std::allocator_arg_t, const Allocator& a );

 (2)

(since C++26)





template< class U = T >

constexpr explicit indirect( U&& v );

 (3)

(since C++26)





template< class U = T >

constexpr explicit indirect( std::allocator_arg_t, const Allocator& a,



                             U&& v );

 (4)

(since C++26)





template< class... Args >

constexpr explicit indirect( std::in_place_t, Args&&... args );

 (5)

(since C++26)





template< class... Args >

constexpr explicit indirect( std::allocator_arg_t, const Allocator& a,



                             std::in_place_t, Args&&... args );

 (6)

(since C++26)





template< class I, class... Args >

constexpr explicit indirect( std::in_place_t, std::initializer_list<I> ilist,



                             Args&&... args );

 (7)

(since C++26)





template< class I, class... Args >

constexpr explicit indirect( std::allocator_arg_t, const Allocator& a,

                             std::in_place_t, std::initializer_list<I> ilist,



                             Args&&... args );

 (8)

(since C++26)





constexpr indirect( const indirect& other );

 (9)

(since C++26)





constexpr indirect( std::allocator_arg_t, const Allocator& a,

                    const indirect& other );

 (10)

(since C++26)





constexpr indirect( indirect&& other ) noexcept;

 (11)

(since C++26)





constexpr indirect( std::allocator_arg_t, const Allocator& a,

                    indirect&& other ) noexcept(/* see below */);

 (12)

(since C++26)







Constructs a new indirect object.



Contents



1 Parameters

2 Effects

3 Constraints and supplement information

4 Exceptions

5 Example

6 See also





[edit] Parameters





 a



 -



 the allocator to be associated





 v



 -



 value with which to initialize the owned value





 args



 -



 arguments with which to initialize the owned value





 il



 -



 initializer list with which to initialize the owned value





 other



 -



 another indirect object whose owned value (if exists) is copied



[edit] Effects

The construction of a new indirect object consists of the following steps:



1) Constructs the associated allocator alloc ﻿:

 If the initializer for alloc is empty, it is value-initialized.

 If the initializer for alloc is not empty, it is direct-non-list-initialized with the initializer argument.



2) Constructs the owned object:

 For overloads (1-8), initialize p with the result of calling std::allocator_traits<Allocator>::allocate, then calls std::allocator_traits<Allocator>::construct(alloc ﻿, p ﻿, args...), where args... is an expression pack containing the initializer arguments.

 For overloads (9-12):

 If other is valueless, no owned object is constructed, and *this is also valueless after construction.

 Otherwise, if other is an rvalue reference and alloc equals other.alloc, *this takes ownership of the owned object of other.

 Otherwise, the owned object is constructed using alloc as described above.









 Overload 



Initializer for...



valueless_after_move()after construction





alloc



the owned object





(1)



(empty)



(empty)



false





(2)



a





(3)



(empty)



std::forward<U>(v)





(4)



a





(5)



(empty)



std::forward<Args>(args)





(6)



a





(7)



(empty)



ilist, std::forward<Args>(args)





(8)



a





(9)



 see below 



*other(only if other owns a value)



true only if other is valueless





(10)



a





(11)



std::move(other.alloc ﻿)



takes ownership(only if other owns a value)





(12)



a



see below



9) alloc is direct-non-list-initialized with std::allocator_traits<Allocator>::    select_on_container_copy_construction(other.alloc ﻿).

12) The owned object is constructed as follows:

 If other is valueless, *this is also valueless.

 Otherwise, if alloc == other.alloc is true, *this takes ownership of the owned object of other.

 Otherwise, constructs an owned object with *std::move(other) using alloc ﻿.



[edit] Constraints and supplement information

1,2) If std::is_default_constructible_v<T> is false, the program is ill-formed.



1) This overload participates in overload resolution only if std::is_default_constructible_v<Allocator> is true.



3-8) These overloads participate in overload resolution only if std::is_constructible_v<T, /* argument types */> is true, where /* argument types */ are:

3,4) U

5,6) Args...

7,8) std::initializer_list<I>&, Args...



3,5,7) These overloads participate in overload resolution only if std::is_default_constructible_v<Allocator> is true.

3,4) These overloads participate in overload resolution only if the following values are all false:

 std::is_same_v<std::remove_cvref_t<U>, std::indirect>

 std::is_same_v<std::remove_cvref_t<U>, std::in_place_t>





9,10) If std::is_copy_constructible_v<T> is false, the program is ill-formed.

11,12) When the construction completes, other is valueless.

12) If std::allocator_traits<Allocator>::is_always_equal::value is false and T is an incomplete type, the program is ill-formed.

[edit] Exceptions

Throws nothing unless std::allocator_traits<Allocator>::allocate or std::allocator_traits<Allocator>::construct throws.



12) noexcept specification:  

noexcept(std::allocator_traits<Allocator>::is_always_equal::value)

[edit] Example

This section is incompleteReason: no example 

[edit] See also





  allocator_arg_t(C++11)



   tag type used to select allocator-aware constructor overloads  (class) [edit]





  in_placein_place_typein_place_indexin_place_tin_place_type_tin_place_index_t(C++17)



 in-place construction tag(tag)[edit]









 





                    