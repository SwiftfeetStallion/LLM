std::indirect[edit] Memory management library



voidify(exposition only*)

Allocators



allocator

allocator_traits(C++11)

allocation_result(C++23)

scoped_allocator_adaptor(C++11)

pmr::polymorphic_allocator(C++17)



allocator_arg(C++11)

uses_allocator(C++11)

uses_allocator_construction_args(C++20)

make_obj_using_allocator(C++20)

uninitialized_construct_using_allocator(C++20)



Uninitialized memory algorithms



uninitialized_copy

uninitialized_fill

uninitialized_move(C++17)

uninitialized_copy_n(C++11)

uninitialized_fill_n

uninitialized_move_n(C++17)

construct_at(C++20)



uninitialized_default_construct(C++17)

uninitialized_value_construct(C++17)

destroy(C++17)

uninitialized_default_construct_n(C++17)

uninitialized_value_construct_n(C++17)

destroy_n(C++17)

destroy_at(C++17)



Constrained uninitialized memory algorithms



ranges::uninitialized_copy(C++20)

ranges::uninitialized_fill(C++20)

ranges::uninitialized_move(C++20)

ranges::uninitialized_copy_n(C++20) 

ranges::uninitialized_fill_n(C++20)

ranges::uninitialized_move_n(C++20)

ranges::construct_at(C++20)



ranges::uninitialized_default_construct(C++20)

ranges::uninitialized_value_construct(C++20)

ranges::destroy(C++20)

ranges::uninitialized_default_construct_n(C++20) 

ranges::uninitialized_value_construct_n(C++20)

ranges::destroy_n(C++20)

ranges::destroy_at(C++20)



Memory resources



pmr::memory_resource(C++17)

pmr::get_default_resource(C++17)

pmr::set_default_resource(C++17)

pmr::new_delete_resource(C++17)

pmr::pool_options(C++17)



pmr::null_memory_resource(C++17)

pmr::synchronized_pool_resource(C++17)

pmr::unsynchronized_pool_resource(C++17)

pmr::monotonic_buffer_resource(C++17)









Explicit lifetime management

start_lifetime_as(C++23)

start_lifetime_as_array(C++23)



Types for composite class design

indirect(C++26)

polymorphic(C++26)



Uninitialized storage (until C++20)



raw_storage_iterator(until C++20*)

get_temporary_buffer(until C++20*)



return_temporary_buffer(until C++20*)







Garbage collector support (until C++23)



declare_reachable(C++11)(until C++23)

declare_no_pointers(C++11)(until C++23)

pointer_safety(C++11)(until C++23)



undeclare_reachable(C++11)(until C++23)

undeclare_no_pointers(C++11)(until C++23)

get_pointer_safety(C++11)(until C++23)





Low level memorymanagement

operator newoperator new[]

operator deleteoperator delete[]

nothrow_t

nothrow

new_handler

set_new_handler

get_new_handler(C++11)

bad_alloc

bad_array_new_length(C++11)

align_val_t(C++17)

destroying_delete_t(C++20)

launder(C++17)

Smart pointers

unique_ptr(C++11)

shared_ptr(C++11)

weak_ptr(C++11)

auto_ptr(until C++17*)

owner_less(C++11)

owner_less<void>(C++17)

owner_hash(C++26)

owner_equal(C++26)

enable_shared_from_this(C++11)

bad_weak_ptr(C++11)

default_delete(C++11)

out_ptr_t(C++23)

inout_ptr_t(C++23)

Miscellaneous

pointer_traits(C++11)

to_address(C++20)

addressof(C++11)

align(C++11)

assume_aligned(C++20)

is_sufficiently_aligned(C++26)

C Library



malloc

calloc

realloc



free

aligned_alloc(C++17)









[edit] std::indirect

Member functions

indirect::indirect

indirect::~indirect

indirect::operator=

Observers

indirect::operator->indirect::operator*

indirect::valueless_after_move

indirect::get_allocator

Modifiers

indirect::swap

Non-member functions

operator==operator<=>

swap(std::indirect)

Deduction guides

Helper classes

hash<std::indirect>

[edit] 





constexpr indirect& operator=( const indirect& other );

 (1)

(since C++26)





constexpr indirect& operator=( indirect&& other ) noexcept(/* see below */);

 (2)

(since C++26)





template< class U = T >

constexpr indirect& operator=( U&& value );

 (3)

(since C++26)







Replaces contents of *this with value or the contents of other.

Let traits be std::allocator_traits<Allocator>:



1) If std::addressof(other) == this is true, does nothing. Otherwise, let need_update be traits::propagate_on_container_copy_assignment::value:

 If other is valueless, *this becomes valueless and the object owned by *this (if any) is destroyed using traits::destroy and then the storage is deallocated.

 Otherwise, if alloc == other.alloc is true and *this is not valueless, equivalent to **this = *other.

 Otherwise:



 Constructs a new owned object in *this using traits::construct with *other as the argument, using the allocator update_alloc ? other.alloc : alloc.

 The previously owned object in *this (if any) is destroyed using traits::destroy and then the storage is deallocated.

 p points to the new owned object.





 After updating the object owned by *this, if need_update is true, alloc is replaced with a copy of other.alloc.

 If std::is_copy_assignable_v<T> && std::is_copy_constructible_v<T> is false, the program is ill-formed.

2) If std::addressof(other) == this is true, does nothing. Otherwise, let need_update be traits::propagate_on_container_move_assignment::value:

 If other is valueless, *this becomes valueless and the object owned by *this (if any) is destroyed using traits::destroy and then the storage is deallocated.

 Otherwise, if alloc == other.alloc is true, swaps the owned objects in *this and other; the owned object in other (if any) is then destroyed using traits::destroy and then the storage is deallocated.

 Otherwise:



 Constructs a new owned object in *this using traits::construct with std::move(*other) as the argument, using the allocator update_alloc ? other.alloc : alloc.

 The previously owned object in *this (if any) is destroyed using traits::destroy and then the storage is deallocated.

 p points to the new owned object.





 After updating the objects owned by *this and other, if need_update is true, alloc is replaced with a copy of other.alloc.

 If std::is_copy_constructible_v<T> is false, the program is ill-formed.

3) If *this is valueless, then constructs an owned object with std::forward<U>(value) using alloc ﻿. Otherwise, equivalent to **this = std::forward<U>(value).

 This overload participates in overload resolution only if all following conditions are satisfied:

 std::is_same_v<std::remove_cvref_t<U>, std::indirect> is false.

 std::is_constructible_v<T, U> is true.

 std::is_assignable_v<T&, U> is true.



Contents



1 Parameters

2 Return value

3 Exceptions

4 Example





[edit] Parameters





 other



 -



 another indirect object whose owned value (if exists) is used for assignment





 value



 -



 value to assign to or construct the owned value



[edit] Return value

*this



[edit] Exceptions

1) If any exception is thrown, the result of this->valueless_after_move() remains unchanged.

 If an exception is thrown during the call to T’s selected copy constructor, no effect.

 If an exception is thrown during the call to T’s copy assignment operator, the state of this->p is as defined by the exception safety guarantee of T’s copy assignment operator.

2) If any exception is thrown, there are no effects on *this or other.

 noexcept specification:  

noexcept(std::allocator_traits<Allocator>::

             propagate_on_container_move_assignment::value



             || std::allocator_traits<Allocator>::is_always_equal::value)

[edit] Example

This section is incompleteReason: no example 





 





                    