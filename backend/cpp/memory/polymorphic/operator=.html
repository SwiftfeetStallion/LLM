std::polymorphic[edit] Memory management library



voidify(exposition only*)

Allocators



allocator

allocator_traits(C++11)

allocation_result(C++23)

scoped_allocator_adaptor(C++11)

pmr::polymorphic_allocator(C++17)



allocator_arg(C++11)

uses_allocator(C++11)

uses_allocator_construction_args(C++20)

make_obj_using_allocator(C++20)

uninitialized_construct_using_allocator(C++20)



Uninitialized memory algorithms



uninitialized_copy

uninitialized_fill

uninitialized_move(C++17)

uninitialized_copy_n(C++11)

uninitialized_fill_n

uninitialized_move_n(C++17)

construct_at(C++20)



uninitialized_default_construct(C++17)

uninitialized_value_construct(C++17)

destroy(C++17)

uninitialized_default_construct_n(C++17)

uninitialized_value_construct_n(C++17)

destroy_n(C++17)

destroy_at(C++17)



Constrained uninitialized memory algorithms



ranges::uninitialized_copy(C++20)

ranges::uninitialized_fill(C++20)

ranges::uninitialized_move(C++20)

ranges::uninitialized_copy_n(C++20) 

ranges::uninitialized_fill_n(C++20)

ranges::uninitialized_move_n(C++20)

ranges::construct_at(C++20)



ranges::uninitialized_default_construct(C++20)

ranges::uninitialized_value_construct(C++20)

ranges::destroy(C++20)

ranges::uninitialized_default_construct_n(C++20) 

ranges::uninitialized_value_construct_n(C++20)

ranges::destroy_n(C++20)

ranges::destroy_at(C++20)



Memory resources



pmr::memory_resource(C++17)

pmr::get_default_resource(C++17)

pmr::set_default_resource(C++17)

pmr::new_delete_resource(C++17)

pmr::pool_options(C++17)



pmr::null_memory_resource(C++17)

pmr::synchronized_pool_resource(C++17)

pmr::unsynchronized_pool_resource(C++17)

pmr::monotonic_buffer_resource(C++17)









Explicit lifetime management

start_lifetime_as(C++23)

start_lifetime_as_array(C++23)



Types for composite class design

indirect(C++26)

polymorphic(C++26)



Uninitialized storage (until C++20)



raw_storage_iterator(until C++20*)

get_temporary_buffer(until C++20*)



return_temporary_buffer(until C++20*)







Garbage collector support (until C++23)



declare_reachable(C++11)(until C++23)

declare_no_pointers(C++11)(until C++23)

pointer_safety(C++11)(until C++23)



undeclare_reachable(C++11)(until C++23)

undeclare_no_pointers(C++11)(until C++23)

get_pointer_safety(C++11)(until C++23)





Low level memorymanagement

operator newoperator new[]

operator deleteoperator delete[]

nothrow_t

nothrow

new_handler

set_new_handler

get_new_handler(C++11)

bad_alloc

bad_array_new_length(C++11)

align_val_t(C++17)

destroying_delete_t(C++20)

launder(C++17)

Smart pointers

unique_ptr(C++11)

shared_ptr(C++11)

weak_ptr(C++11)

auto_ptr(until C++17*)

owner_less(C++11)

owner_less<void>(C++17)

owner_hash(C++26)

owner_equal(C++26)

enable_shared_from_this(C++11)

bad_weak_ptr(C++11)

default_delete(C++11)

out_ptr_t(C++23)

inout_ptr_t(C++23)

Miscellaneous

pointer_traits(C++11)

to_address(C++20)

addressof(C++11)

align(C++11)

assume_aligned(C++20)

is_sufficiently_aligned(C++26)

C Library



malloc

calloc

realloc



free

aligned_alloc(C++17)









[edit] std::polymorphic

Member functions

polymorphic::polymorphic

polymorphic::~polymorphic

polymorphic::operator=

Observers

polymorphic::operator->polymorphic::operator*

polymorphic::valueless_after_move

polymorphic::get_allocator

Modifiers

polymorphic::swap

Non-member functions

swap(std::polymorphic)

[edit] 





constexpr polymorphic& operator=( const polymorphic& other );

 (1)

(since C++26)





constexpr polymorphic& operator=( polymorphic&& other )

    noexcept(/* see below */);

 (2)

(since C++26)







Replaces contents of *this with the contents of other.

Let traits be std::allocator_traits<Allocator>:



1) If std::addressof(other) == this is true, does nothing. Otherwise, let need_update be traits::propagate_on_container_copy_assignment::value:

 If other is valueless, proceeds to the next step. Otherwise, constructs a new owned object in *this using traits::construct with *other as the argument, using the allocator update_alloc ? other.alloc : alloc.

 The previously owned object in *this (if any) is destroyed using traits::destroy and then the storage is deallocated.



 After updating the object owned by *this, if need_update is true, alloc is replaced with a copy of other.alloc.

 If T is an incomplete type, the program is ill-formed.

2) If std::addressof(other) == this is true, does nothing. Otherwise, let need_update be traits::propagate_on_container_move_assignment::value:

 If alloc == other.alloc is true, swaps the owned objects in *this and other; the owned object in other (if any) is then destroyed using traits::destroy and then the storage is deallocated.

 Otherwise:



 If other is valueless, proceeds to the next step. Otherwise, constructs a new owned object in *this using traits::construct with std::move(*other) as the argument, using the allocator update_alloc ? other.alloc : alloc.

 The previously owned object in *this (if any) is destroyed using traits::destroy and then the storage is deallocated.





 After updating the objects owned by *this and other, if need_update is true, alloc is replaced with a copy of other.alloc.

 If all following conditions are satisfied, the program is ill-formed:

 std::allocator_traits<Allocator>::is_always_equal::value is false.

 T is an incomplete type.



Contents



1 Parameters

2 Return value

3 Exceptions

4 Example





[edit] Parameters





 other



 -



 another polymorphic object whose owned value (if exists) is used for assignment



[edit] Return value

*this



[edit] Exceptions

1) If any exception is thrown, there are no effects on *this.

2) If any exception is thrown, there are no effects on *this or other.

 noexcept specification:  

noexcept(std::allocator_traits<Allocator>::

             propagate_on_container_move_assignment::value



             || std::allocator_traits<Allocator>::is_always_equal::value)

[edit] Example

This section is incompleteReason: no example 





 





                    