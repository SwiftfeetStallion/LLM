std::allocate_shared, std::allocate_shared_for_overwrite









From cppreference.com





[edit] Memory management library



voidify(exposition only*)

Allocators



allocator

allocator_traits(C++11)

allocation_result(C++23)

scoped_allocator_adaptor(C++11)

pmr::polymorphic_allocator(C++17)



allocator_arg(C++11)

uses_allocator(C++11)

uses_allocator_construction_args(C++20)

make_obj_using_allocator(C++20)

uninitialized_construct_using_allocator(C++20)



Uninitialized memory algorithms



uninitialized_copy

uninitialized_fill

uninitialized_move(C++17)

uninitialized_copy_n(C++11)

uninitialized_fill_n

uninitialized_move_n(C++17)

construct_at(C++20)



uninitialized_default_construct(C++17)

uninitialized_value_construct(C++17)

destroy(C++17)

uninitialized_default_construct_n(C++17)

uninitialized_value_construct_n(C++17)

destroy_n(C++17)

destroy_at(C++17)



Constrained uninitialized memory algorithms



ranges::uninitialized_copy(C++20)

ranges::uninitialized_fill(C++20)

ranges::uninitialized_move(C++20)

ranges::uninitialized_copy_n(C++20) 

ranges::uninitialized_fill_n(C++20)

ranges::uninitialized_move_n(C++20)

ranges::construct_at(C++20)



ranges::uninitialized_default_construct(C++20)

ranges::uninitialized_value_construct(C++20)

ranges::destroy(C++20)

ranges::uninitialized_default_construct_n(C++20) 

ranges::uninitialized_value_construct_n(C++20)

ranges::destroy_n(C++20)

ranges::destroy_at(C++20)



Memory resources



pmr::memory_resource(C++17)

pmr::get_default_resource(C++17)

pmr::set_default_resource(C++17)

pmr::new_delete_resource(C++17)

pmr::pool_options(C++17)



pmr::null_memory_resource(C++17)

pmr::synchronized_pool_resource(C++17)

pmr::unsynchronized_pool_resource(C++17)

pmr::monotonic_buffer_resource(C++17)









Explicit lifetime management

start_lifetime_as(C++23)

start_lifetime_as_array(C++23)



Types for composite class design

indirect(C++26)

polymorphic(C++26)



Uninitialized storage (until C++20)



raw_storage_iterator(until C++20*)

get_temporary_buffer(until C++20*)



return_temporary_buffer(until C++20*)







Garbage collector support (until C++23)



declare_reachable(C++11)(until C++23)

declare_no_pointers(C++11)(until C++23)

pointer_safety(C++11)(until C++23)



undeclare_reachable(C++11)(until C++23)

undeclare_no_pointers(C++11)(until C++23)

get_pointer_safety(C++11)(until C++23)





Low level memorymanagement

operator newoperator new[]

operator deleteoperator delete[]

nothrow_t

nothrow

new_handler

set_new_handler

get_new_handler(C++11)

bad_alloc

bad_array_new_length(C++11)

align_val_t(C++17)

destroying_delete_t(C++20)

launder(C++17)

Smart pointers

unique_ptr(C++11)

shared_ptr(C++11)

weak_ptr(C++11)

auto_ptr(until C++17*)

owner_less(C++11)

owner_less<void>(C++17)

owner_hash(C++26)

owner_equal(C++26)

enable_shared_from_this(C++11)

bad_weak_ptr(C++11)

default_delete(C++11)

out_ptr_t(C++23)

inout_ptr_t(C++23)

Miscellaneous

pointer_traits(C++11)

to_address(C++20)

addressof(C++11)

align(C++11)

assume_aligned(C++20)

is_sufficiently_aligned(C++26)

C Library



malloc

calloc

realloc



free

aligned_alloc(C++17)









[edit] std::shared_ptr

Member functions

shared_ptr::shared_ptr

shared_ptr::~shared_ptr

shared_ptr::operator=

Modifiers

shared_ptr::reset

shared_ptr::swap

Observers

shared_ptr::get

shared_ptr::operator*shared_ptr::operator->

shared_ptr::operator[](C++17)

shared_ptr::use_count

shared_ptr::unique(until C++20*)

shared_ptr::operator bool

shared_ptr::owner_before

shared_ptr::owner_hash(C++26)

shared_ptr::owner_equal(C++26)

Non-member functions

swap(std::shared_ptr)

make_sharedmake_shared_for_overwrite(C++20)

allocate_sharedallocate_shared_for_overwrite(C++20)

static_pointer_castdynamic_pointer_castconst_pointer_castreinterpret_pointer_cast(C++17)

get_deleter

operator==operator!=operator<operator<=operator>operator>=operator<=>(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)(C++20)

operator<<

atomic_xxxfunctions (until C++26*)

Helper classes

atomic<std::shared_ptr>(C++20)

hash<std::shared_ptr>

Deduction guides(C++17)

[edit] 





 Defined in header <memory>











 template< class T, class Alloc, class... Args >

shared_ptr<T> allocate_shared( const Alloc& alloc, Args&&... args );

 (1) 

 (since C++11) 





 template< class T, class Alloc >

shared_ptr<T> allocate_shared( const Alloc& alloc, std::size_t N );

 (2) 

 (since C++20) 





 template< class T, class Alloc >

shared_ptr<T> allocate_shared( const Alloc& alloc );

 (3) 

 (since C++20) 





 template< class T, class Alloc >

shared_ptr<T> allocate_shared( const Alloc& alloc, std::size_t N,



                               const std::remove_extent_t<T>& u );

 (4) 

 (since C++20) 





 template< class T, class Alloc >

shared_ptr<T> allocate_shared( const Alloc& alloc,



                               const std::remove_extent_t<T>& u );

 (5) 

 (since C++20) 





template< class T, class Alloc >

shared_ptr<T> allocate_shared_for_overwrite( const Alloc& alloc );

 (6)

(since C++20)





 template< class T, class Alloc >

shared_ptr<T> allocate_shared_for_overwrite( const Alloc& alloc,



                                             std::size_t N );

 (7) 

 (since C++20) 







Allocates memory for an object using a copy of alloc (rebound for an unspecified value_type) and initialize the object with the supplied arguments. Returns a std::shared_ptr object managing the newly created object.



1) The object is of type T, and is constructed as if by std::allocator_traits<Alloc>::construct    (a, pt, (std::forward<Args>(args)...), where pt is a std::remove_cv_t<T>* pointer to storage suitable to hold an object of type std::remove_cv_t<T>. If the object is to be destroyed, it is destroyed as if by std::allocator_traits<Alloc>::destroy(a, pt), where pt is a pointer to that object of type std::remove_cv_t<T>.

 In the description above, a is of type Alloc, and it is a potentially rebound copy of alloc.





This overload participates in overload resolution only if T is not an array type.





(since C++20)



2) The object is of type std::remove_extent_t<T>[N]. Each element has a default initial value.

 This overload participates in overload resolution only if T is an unbounded array type.

3) The object is of type T. Each element has a default initial value.

 This overload participates in overload resolution only if T is a bounded array type.

4) The object is of type std::remove_extent_t<T>[N]. Each element has the initial value u.

 This overload participates in overload resolution only if T is an unbounded array type.

5) The object is of type T. Each element has the initial value u.

 This overload participates in overload resolution only if T is a bounded array type.

6) The object is of type T.

 If T is not an array type, the object is constructed as if by ::new (pv) T, where pv is a void* pointer to storage suitable to hold an object of type T. If the object is to be destroyed, it is destroyed as if by pt->~T(), where pt is a pointer to that object of type T.

 If T is a bounded array type, the initial value is unspecified for each element.



 This overload participates in overload resolution only if T is not an array type or is an bounded array type.

7) The object is of type std::remove_extent_t<T>[N]. The initial value is unspecified for each element.

 This overload participates in overload resolution only if T is an unbounded array type.





Contents



1 Initializing and destroying array elements

2 Parameters

3 Return value

4 Exceptions

5 Notes

6 Example

7 Defect reports

8 See also





 Initializing and destroying array elements

In the description below, a is of type Alloc, and it is a potentially rebound copy of alloc.

Array elements of type U are initialized in ascending order of their addresses.



 If U is not an array type, each element is constructed as if by the following expression, where pu is a std::remove_cv_t<U>* pointer to storage suitable to hold an object of type std::remove_cv_t<U>, and pv is a void* pointer to storage suitable to hold an object of type U:



2,3) std::allocator_traits<Alloc>::construct(a, pu)

4,5) std::allocator_traits<Alloc>::construct(a, pu, u)

6,7) ::new (pv) U

 Otherwise, recursively initializes the elements of each element. For the next dimension:



 U becomes std::remove_extent_t<U>.

 For overloads (4,5), u becomes the corresponding element of u.





When the lifetime of the object managed by the return std::shared_ptr ends, or when the initialization of an array element throws an exception, the initialized elements are destroyed in the reverse order of their original construction.

For each array element of non-array type U to be destroyed, it is destroyed as if by the following expression:



2-5) std::allocator_traits<Alloc>::destroy(a, pu), where pu is a U* pointer to that array element of type U

6,7) pu->~U(), where pu is a pointer to that array element of type U



(since C++20)



[edit] Parameters





 alloc



 -



 the Allocator to use





 args...



 -



 list of arguments with which an instance of T will be constructed





 N



 -



 array size to use





 u



 -



 the initial value to initialize every element of the array



[edit] Return value

std::shared_ptr to an object of type T or std::remove_extent_t<T>[N] if T is an unbounded array type(since C++20).

For the returned std::shared_ptr r, r.get() returns a non-null pointer and r.use_count() returns 1.



[edit] Exceptions

Can throw the exceptions thrown from Alloc::allocate() or from the constructor of T. If an exception is thrown, (1) has no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order(since C++20).



[edit] Notes

These functions will typically allocate more memory than sizeof(T) to allow for internal bookkeeping structures such as reference counts.

Like std::make_shared, this function typically performs only one allocation, and places both the T object and the control block in the allocated memory block (the standard recommends but does not require this, all known implementations do this). A copy of alloc is stored as part of the control block so that it can be used to deallocate it once both shared and weak reference counts reach zero.

Unlike the std::shared_ptr constructors, std::allocate_shared does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the T object, and for deallocation of their shared memory block.







std::shared_ptr supports array types (as of C++17), but std::allocate_shared does not. This functionality is supported by boost::allocate_shared.





(until C++20)



A constructor enables shared_from_this with a pointer ptr of type U* means that it determines if U has an unambiguous and accessible(since C++17) base class that is a specialization of std::enable_shared_from_this, and if so, the constructor evaluates 

if (ptr != nullptr && ptr->weak_this ﻿.expired())

    ptr->weak_this = std::shared_ptr<std::remove_cv_t<U>>

        (*this, const_cast<std::remove_cv_t<U>*>(ptr));

.

The assignment to the weak_this is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to shared_from_this() would share ownership with the std::shared_ptr created by this raw pointer constructor.

The test ptr->weak_this ﻿.expired() in the code above makes sure that weak_this is not reassigned if it already indicates an owner. This test is required as of C++17.







Feature-test macro

Value

Std

Feature





__cpp_lib_smart_ptr_for_overwrite

202002L

(C++20)

Smart pointer creation with default initialization (std::allocate_shared_for_overwrite, std::make_shared_for_overwrite, std::make_unique_for_overwrite); overloads (6,7)



[edit] Example

Run this code

#include <cstddef>

#include <iostream>

#include <memory>

#include <memory_resource>

#include <vector>

 

class Value

{

    int i;

public:

    Value(int i) : i(i) { std::cout << "Value(), i = " << i << '\n'; }

    ~Value() { std::cout << "~Value(), i = " << i << '\n'; }

    void print() const { std::cout << "i = " << i << '\n'; }

};

 

int main()

{

    // Create a polymorphic allocator using the monotonic buffer resource

    std::byte buffer[sizeof(Value) * 8];

    std::pmr::monotonic_buffer_resource resource(buffer, sizeof(buffer));

    std::pmr::polymorphic_allocator<Value> allocator(&resource);

 

    std::vector<std::shared_ptr<Value>> v;

 

    for (int i{}; i != 4; ++i)

        // Use std::allocate_shared with the custom allocator

        v.emplace_back(std::allocate_shared<Value>(allocator, i));

 

    for (const auto& sp : v)

        sp->print();

} //< All shared pointers will automatically clean up when they go out of scope.

Output:



Value(), i = 0

Value(), i = 1

Value(), i = 2

Value(), i = 3

i = 0

i = 1

i = 2

i = 3

~Value(), i = 0

~Value(), i = 1

~Value(), i = 2

~Value(), i = 3



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 3216



C++20



std::allocate_shared always rebound theallocator before constructing and destroying objects



rebind is optional





LWG 4024



C++20



it was unclear how the objects constructed instd::allocate_shared_for_overwrite are destroyed



made clear



[edit] See also





  (constructor)



  constructs new shared_ptr  (public member function) [edit]





  make_sharedmake_shared_for_overwrite(C++20)



  creates a shared pointer that manages a new object  (function template) [edit]









 





                    