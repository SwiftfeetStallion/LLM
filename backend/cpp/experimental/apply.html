std::experimental::apply









From cppreference.com





[edit] Experimental

Technical Specification

Filesystem library (filesystem TS)

Library fundamentals (library fundamentals TS)

Library fundamentals 2 (library fundamentals TS v2)

Library fundamentals 3 (library fundamentals TS v3)

Extensions for parallelism (parallelism TS)

Extensions for parallelism 2 (parallelism TS v2)

Extensions for concurrency (concurrency TS)

Extensions for concurrency 2 (concurrency TS v2)

Concepts (concepts TS)

Ranges (ranges TS)

Reflection (reflection TS)

Mathematical special functions (special functions TR)

Experimental Non-TS

Pattern Matching

Linear Algebra

std::execution

Contracts

2D Graphics

[edit] Library fundamentals

experimental::optional

experimental::any

experimental::basic_string_view

experimental::sample

experimental::shared_ptr

experimental::weak_ptr

experimental::apply

experimental::invocation_typeexperimental::raw_invocation_type

experimental::search

experimental::default_searcherexperimental::make_default_searcher

experimental::boyer_moore_searcherexperimental::make_boyer_moore_searcher

experimental::boyer_moore_horspool_searcherexperimental::make_boyer_moore_horspool_searcher

Type-erased and polymorphic allocators

Variable templates for type traits

[edit] 









 Merged into ISO C++ The functionality described on this page was merged into the mainline ISO C++ standard as of 3/2016, see  std::apply (since C++17) 









 Defined in header <experimental/tuple>











 template< class F, class Tuple >

constexpr decltype(auto) apply(F&& f, Tuple&& t);

 

 (library fundamentals TS) 







Invoke the Callable object f with a tuple of arguments.



Contents



1 Parameters

2 Return value

3 Possible implementation

4 Example

5 See also





[edit] Parameters





 f



 -



 Callable object to be invoked





 t



 -



 tuple whose elements to be used as arguments to f



[edit] Return value

What returned by f.



[edit] Possible implementation







namespace detail

{

    template<class F, class Tuple, std::size_t... I>

    constexpr decltype(auto) apply_impl(F&& f, Tuple&& t, std::index_sequence<I...>)

    {

        return std::invoke(std::forward<F>(f), std::get<I>(std::forward<Tuple>(t))...);

        // Note: std::invoke is a C++17 feature

    }

} // namespace detail

 

template<class F, class Tuple>

constexpr decltype(auto) apply(F&& f, Tuple&& t)

{

    return detail::apply_impl(std::forward<F>(f), std::forward<Tuple>(t),

        std::make_index_sequence<std::tuple_size_v<std::decay_t<Tuple>>>{});

}



[edit] Example

Run this code

#include <iostream>

#include <tuple>

 

template<typename... Ts>

void print_tuple(const std::tuple<Ts...> &tuple)

{

    std::apply([](const auto&... elem) 

    {

        ((std::cout << elem << '\n'), ...); 

    }, tuple);

}

 

int main()

{

    const std::tuple<int, char> t = std::make_tuple(5, 'a');

    print_tuple(t);

}

Output:



5

a



[edit] See also





  make_tuple(C++11)



  creates a tuple object of the type defined by the argument types  (function template) [edit]





  forward_as_tuple(C++11)



  creates a tuple of forwarding references  (function template) [edit]









 





                    