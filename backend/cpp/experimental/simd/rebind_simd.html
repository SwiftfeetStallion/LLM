std::experimental::rebind_simd, std::experimental::resize_simd









From cppreference.com





[edit] Experimental

Technical Specification

Filesystem library (filesystem TS)

Library fundamentals (library fundamentals TS)

Library fundamentals 2 (library fundamentals TS v2)

Library fundamentals 3 (library fundamentals TS v3)

Extensions for parallelism (parallelism TS)

Extensions for parallelism 2 (parallelism TS v2)

Extensions for concurrency (concurrency TS)

Extensions for concurrency 2 (concurrency TS v2)

Concepts (concepts TS)

Ranges (ranges TS)

Reflection (reflection TS)

Mathematical special functions (special functions TR)

Experimental Non-TS

Pattern Matching

Linear Algebra

std::execution

Contracts

2D Graphics

[edit] Extensions for parallelism v2

Parallel exceptions

exception_list

Additional execution policies



execution::vector_policy



execution::unsequenced_policy



Algorithms



induction

reductionreduction_plusreduction_minusreduction_multiplies

                                        



reduction_bit_andreduction_bit_orreduction_bit_xorreduction_minreduction_max

                                        



for_loopfor_loop_stridedfor_loop_nfor_loop_n_strided











execution::no_vec

execution::ordered_update_t

Task blocks

task_block

task_cancelled_exception

define_task_blockdefine_task_block_restore_thread

Data-parallel vectors

[edit] SIMD library

Main classes



simd



simd_mask



ABI tags



simd_abi::scalar

simd_abi::fixed_size    



simd_abi::native

simd_abi::compatible    



simd_abi::max_fixed_size

simd_abi::deduce



Alignment tags



element_aligned_tagelement_aligned



vector_aligned_tagvector_aligned



overaligned_tagoveraligned



Where expression



where



where_expression



const_where_expression



Casts



simd_caststatic_simd_cast







to_fixed_sizeto_compatibleto_native



splitsplit_by

concat



Algorithms



min

max



minmax

clamp



Reduction



reducehminhmax



Mask reduction



all_ofany_ofnone_ofsome_of



popcount

find_first_setfind_last_set







Traits



is_simdis_simd_mask

is_abi_tag

is_simd_flag_type



simd_size

memory_alignment

rebind_simdresize_simd



Math functions

[edit] 





 Defined in header <experimental/simd>











 template< class T, class V >

struct rebind_simd;

 (1) 

 (parallelism TS v2) 





 template< int N, class V >

struct resize_simd;

 (2) 

 (parallelism TS v2) 







Creates a simd or simd_mask type with a different element type or size. The new type likely uses an ABI tag type different from V::abi_type.



1) Changes the element type to T and keeps the size unchanged.

2) Changes the size to N and keeps the element type unchanged.

Contents



1 Template parameters

2 Member types

3 Helper types

4 Example

5 See also





[edit] Template parameters





 T



 -



 the new element type; an arithmetic type other than bool





 N



 -



 the new number of elements





 V



 -



 a simd or simd_mask type



[edit] Member types





 Name



 Definition





 type



 simd or simd_mask type with a different element type (1) or size (2)





[edit] Helper types





 template< class T, class V >

using rebind_simd_t = typename rebind_simd<T, V>::type;

 

 (parallelism TS v2) 





 template< int N, class V >

using resize_simd_t = typename resize_simd<N, V>::type;

 

 (parallelism TS v2) 







[edit] Example

Run this code

#include <experimental/simd>

#include <iostream>

 

namespace stdx = std::experimental;

using floatv = stdx::native_simd<float>;

 

// use double precision internally

floatv dp(floatv x)

{

    using doublev = stdx::rebind_simd_t<double, floatv>;

    return stdx::static_simd_cast<floatv>(stdx::simd_cast<doublev>(x) - 1.234);

}

 

template<class T>

stdx::resize_simd_t<T::size() / 2, T> partial_reduction(T x)

{

    auto [lo, hi] = stdx::split<stdx::resize_simd_t<T::size() / 2, T>>(x);

    return lo + hi;

}

 

int main() 

{

    floatv x([](auto i) { return 1.234f + std::numeric_limits<float>::epsilon() * i; });

    x = dp(x);

    const auto y = partial_reduction(x);

    for (unsigned i = 0; i < y.size(); ++i)

        std::cout << y[i] << ' ';

    std::cout << '\n';

}

Possible output:



1.73569e-07 4.11987e-07



[edit] See also





  deducededuce_t(parallelism TS v2)



  obtains an ABI type for given element type and number of elements  (class template) [edit]









 





                    