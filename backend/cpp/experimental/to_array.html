std::experimental::to_array









From cppreference.com





[edit] Experimental

Technical Specification

Filesystem library (filesystem TS)

Library fundamentals (library fundamentals TS)

Library fundamentals 2 (library fundamentals TS v2)

Library fundamentals 3 (library fundamentals TS v3)

Extensions for parallelism (parallelism TS)

Extensions for parallelism 2 (parallelism TS v2)

Extensions for concurrency (concurrency TS)

Extensions for concurrency 2 (concurrency TS v2)

Concepts (concepts TS)

Ranges (ranges TS)

Reflection (reflection TS)

Mathematical special functions (special functions TR)

Experimental Non-TS

Pattern Matching

Linear Algebra

std::execution

Contracts

2D Graphics

[edit] Library fundamentals v2

experimental::propagate_const

experimental::not_fn

experimental::observer_ptr

experimental::make_array

experimental::to_array

experimental::ostream_joiner

experimental::gcd

experimental::lcm

experimental::source_location

experimental::randint

detection idiom

uniform container erasure

logical operator type traits

[edit] 









 Merged into ISO C++ The functionality described on this page was merged into the mainline ISO C++ standard as of 7/2019, see  std::to_array (since C++20) 









 Defined in header <experimental/array>











 template< class T, std::size_t N >

constexpr std::array<std::remove_cv_t<T>, N> to_array(T (&a)[N]);

 

 (library fundamentals TS v2) 







Creates a std::array from the built-in array a. The elements of the std::array are copy-initialized from the corresponding element of a.



Contents



1 Parameters

2 Return value

3 Possible implementation

4 Example

5 See also





[edit] Parameters





 a



 -



 the built-in array to be used to initialize the std::array



[edit] Return value

An std::array object whose elements are copy-initialized from the corresponding element of a.



[edit] Possible implementation







namespace detail

{

    template<class T, std::size_t N, std::size_t... I>

    constexpr std::array<std::remove_cv_t<T>, N>

        to_array_impl(T (&a)[N], std::index_sequence<I...>)

    {

        return { {a[I]...} };

    }

}

 

template<class T, std::size_t N>

constexpr std::array<std::remove_cv_t<T>, N> to_array(T (&a)[N])

{

    return detail::to_array_impl(a, std::make_index_sequence<N>{});

}



[edit] Example

Run this code

#include <cassert>

#include <cstdlib>

#include <experimental/array>

#include <unistd.h>

 

// mkstemp(3) that works

template<std::size_t N>

int tempfd(char const (&tmpl)[N])

{

    auto s = std::experimental::to_array(tmpl);

    int fd = mkstemp(s.data());

    if (fd != -1)

        unlink(s.data());

 

    return fd;

}

 

int main()

{

    int fd = tempfd("/tmp/test.XXXXXX");

    int rt = close(fd);

    assert(rt == 0);

}



[edit] See also





  make_array(library fundamentals TS v2)



  creates a std::array object whose size and optionally element type are deduced from the arguments  (function template) [edit]









 





                    