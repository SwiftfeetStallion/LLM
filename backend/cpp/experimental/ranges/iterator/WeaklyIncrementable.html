std::experimental::ranges::WeaklyIncrementable









From cppreference.com





[edit] Experimental

Technical Specification

Filesystem library (filesystem TS)

Library fundamentals (library fundamentals TS)

Library fundamentals 2 (library fundamentals TS v2)

Library fundamentals 3 (library fundamentals TS v3)

Extensions for parallelism (parallelism TS)

Extensions for parallelism 2 (parallelism TS v2)

Extensions for concurrency (concurrency TS)

Extensions for concurrency 2 (concurrency TS v2)

Concepts (concepts TS)

Ranges (ranges TS)

Reflection (reflection TS)

Mathematical special functions (special functions TR)

Experimental Non-TS

Pattern Matching

Linear Algebra

std::execution

Contracts

2D Graphics

[edit] Ranges

Concepts

General utilities

Iterators

Ranges

Algorithms

[edit] Iterators library

 Iterator concepts



Readable

Writable

WeaklyIncrementable

Incrementable



Iterator

Sentinel

SizedSentinel







InputIterator

ForwardIterator

BidirectionalIterator

RandomAccessIterator



OutputIterator















 Indirect callable concepts



IndirectUnaryInvocableIndirectRegularUnaryInvocable



IndirectUnaryPredicate

                                                  



IndirectRelation

                                                  



IndirectStrictWeakOrder

                                                  



 Common algorithm requirements



IndirectlyMovable

IndirectlyMovableStorable

                                                  



IndirectlyCopyable

IndirectlyCopyableStorable







IndirectlySwappable

IndirectlyComparable







Permutable

Mergeable

Sortable



 Concept utilities



indirect_result_of



projected



 Iterator utilities and operations



iter_move

iter_swap



advance

distance



next

prev



 Iterator traits



difference_type

value_type

reference_trvalue_reference_titer_common_reference_t

iterator_category



input_iterator_tagoutput_iterator_tagforward_iterator_tagbidirectional_iterator_tagrandom_access_iterator_tag







ranges::iterator_traits

std::iterator_traits<InputIterator>std::iterator_traits<OutputIterator>















 Iterator adaptors



reverse_iterator

move_iterator

move_sentinel



back_insert_iterator

front_insert_iterator

insert_iterator



common_iterator

counted_iterator

default_sentinel



danglingborrowed_iterator_t

unreachable



 Stream iterators



istream_iterator



ostream_iterator



istreambuf_iterator



ostreambuf_iterator



[edit] 





 Defined in header <experimental/ranges/iterator>











 template< class I >

concept bool WeaklyIncrementable =

    Semiregular<I> &&

    requires(I i) {

        typename ranges::difference_type_t<I>;

        requires SignedIntegral<ranges::difference_type_t<I>>;

        { ++i } -> Same<I>&; /* not required to be equality preserving */

        i++; /* not required to be equality preserving */



    };

 

 (ranges TS) 







The concept WeaklyIncrementable<I> specifies the requirements on a type that can be incremented (with the pre- and post-increment operators). The increment operations need not be equality-preserving, and the type need not be EqualityComparable.

Let i be an object of type I. i is said to be incrementable if it is in the domain of both pre- and post-increment. WeaklyIncrementable<I> is satisfied only if:



 ++i and i++ have the same domain;

 If i is incrementable, then:

 ++i and i++ both advance i to the next element; and

 ++i refers to the same object as i.





[edit]  Equality preservation 

An expression is equality preserving if it results in equal outputs given equal inputs. 



 The inputs to an expression consist of its operands.

 The outputs of an expression consist of its result and all operands modified by the expression (if any).



Every expression required to be equality preserving is further required to be stable: two evaluations of such an expression with the same input objects must have equal outputs absent any explicit intervening modification of those input objects.



[edit] Notes

For WeaklyIncrementable types, a equals b does not imply that ++a equals ++b. Algorithms on such types should be single pass and never attempt to pass through the same value twice.







 





                    