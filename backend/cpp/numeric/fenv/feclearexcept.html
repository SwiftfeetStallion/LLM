std::feclearexcept









From cppreference.com





[edit] Numerics library

Common mathematical functions

Mathematical special functions (C++17)

Mathematical constants (C++20)

Basic linear algebra algorithms (C++26)

Data-parallel types (SIMD) (C++26)

Floating-point environment (C++11)

Complex numbers

Numeric array (valarray)

Pseudo-random number generation

Bit manipulation (C++20)

Saturation arithmetic (C++26)

Factor operations



gcd(C++17)



lcm(C++17)



Interpolations



midpoint(C++20)



lerp(C++20)



Generic numeric operations



iota(C++11)

ranges::iota(C++23)

accumulate

inner_product

adjacent_difference  

partial_sum



reduce(C++17)

transform_reduce(C++17)

inclusive_scan(C++17)

exclusive_scan(C++17)

transform_inclusive_scan(C++17)

transform_exclusive_scan(C++17)



C-style checked integer arithmetic



ckd_add(C++26)

ckd_sub(C++26)



ckd_mul(C++26)







[edit] Floating-point environment

Functions

feclearexcept(C++11)

fetestexcept(C++11)

feraiseexcept(C++11)

fegetexceptflagfesetexceptflag(C++11)(C++11)

fegetroundfesetround(C++11)(C++11)

fegetenvfesetenv(C++11)(C++11)

feholdexcept(C++11)

feupdateenv(C++11)

Macro constants

FE_ALL_EXCEPTFE_DIVBYZEROFE_INEXACTFE_INVALIDFE_OVERFLOWFE_UNDERFLOW(C++11)(C++11)(C++11)(C++11)(C++11)(C++11)

FE_DOWNWARDFE_TONEARESTFE_TOWARDZEROFE_UPWARD(C++11)(C++11)(C++11)(C++11)

FE_DFL_ENV(C++11)

[edit] 





 Defined in header <cfenv>











 int feclearexcept( int excepts );

 

 (since C++11) 







Attempts to clear the floating-point exceptions that are listed in the bitmask argument excepts, which is a bitwise OR of the floating point exception macros.



Contents



1 Parameters

2 Return value

3 Example

4 See also





[edit] Parameters





  excepts



 -



  bitmask listing the exception flags to clear



[edit] Return value

​0​ if all indicated exceptions were successfully cleared or if excepts is zero. Returns a non-zero value on error.



[edit] Example



[edit]Run this code

#include <cfenv>

#include <cmath>

#include <iostream>

 

// #pragma STDC FENV_ACCESS ON

 

volatile double zero = 0.0; // volatile not needed where FENV_ACCESS is supported

volatile double one = 1.0;  // volatile not needed where FENV_ACCESS is supported

 

int main()

{

    std::feclearexcept(FE_ALL_EXCEPT);

    std::cout <<  "1.0/0.0 = " << 1.0 / zero << '\n';

    if (std::fetestexcept(FE_DIVBYZERO))

        std::cout << "division by zero reported\n";

    else

        std::cout << "division by zero not reported\n";

 

    std::feclearexcept(FE_ALL_EXCEPT);

    std::cout << "1.0/10 = " << one / 10 << '\n';

    if (std::fetestexcept(FE_INEXACT))

        std::cout << "inexact result reported\n";

    else

        std::cout << "inexact result not reported\n";

 

    std::feclearexcept(FE_ALL_EXCEPT);

    std::cout << "sqrt(-1) = " << std::sqrt(-1) << '\n';

    if (std::fetestexcept(FE_INVALID))

        std::cout << "invalid result reported\n";

    else

        std::cout << "invalid result not reported\n";

}

Possible output:



1.0/0.0 = inf

division by zero reported

1.0/10 = 0.1

inexact result reported

sqrt(-1) = -nan

invalid result reported



[edit] See also





  fetestexcept(C++11)



  determines which of the specified floating-point status flags are set  (function) [edit]





 C documentation for feclearexcept









 





                    