std::lcm









From cppreference.com





[edit] Numerics library

Common mathematical functions

Mathematical special functions (C++17)

Mathematical constants (C++20)

Basic linear algebra algorithms (C++26)

Data-parallel types (SIMD) (C++26)

Floating-point environment (C++11)

Complex numbers

Numeric array (valarray)

Pseudo-random number generation

Bit manipulation (C++20)

Saturation arithmetic (C++26)

Factor operations



gcd(C++17)



lcm(C++17)



Interpolations



midpoint(C++20)



lerp(C++20)



Generic numeric operations



iota(C++11)

ranges::iota(C++23)

accumulate

inner_product

adjacent_difference  

partial_sum



reduce(C++17)

transform_reduce(C++17)

inclusive_scan(C++17)

exclusive_scan(C++17)

transform_inclusive_scan(C++17)

transform_exclusive_scan(C++17)



C-style checked integer arithmetic



ckd_add(C++26)

ckd_sub(C++26)



ckd_mul(C++26)







[edit] 





 Defined in header <numeric>











 template< class M, class N >

constexpr std::common_type_t<M, N> lcm( M m, N n );

 

 (since C++17) 







Computes the least common multiple of the integers m and n.

If either M or N is not an integer type, or if either is (possibly cv-qualified) bool, the program is ill-formed.

The behavior is undefined if |m|, |n|, or the least common multiple of |m| and |n| is not representable as a value of type std::common_type_t<M, N>.



Contents



1 Parameters

2 Return value

3 Exceptions

4 Notes

5 Example

6 See also





[edit] Parameters





 m, n



 -



 integer values



[edit] Return value

If either m or n is zero, returns zero. Otherwise, returns the least common multiple of |m| and |n|.



[edit] Exceptions

Throws no exceptions.



[edit] Notes





Feature-test macro

Value

Std

Feature





__cpp_lib_gcd_lcm

201606L

(C++17)

std::gcd, std::lcm



[edit] Example

Run this code

#include <iostream>

#include <numeric>

 

#define OUT(...) std::cout << #__VA_ARGS__ << " = " << __VA_ARGS__ << '\n'

 

constexpr auto lcm(auto x, auto... xs)

{

    return ((x = std::lcm(x, xs)), ...);

}

 

int main()

{

    constexpr int p{2 * 2 * 3};

    constexpr int q{2 * 3 * 3};

    static_assert(2 * 2 * 3 * 3 == std::lcm(p, q));

    static_assert(225 == std::lcm(45, 75));

 

    static_assert(std::lcm( 6,  10) == 30);

    static_assert(std::lcm( 6, -10) == 30);

    static_assert(std::lcm(-6, -10) == 30);

 

    static_assert(std::lcm( 24, 0) == 0);

    static_assert(std::lcm(-24, 0) == 0);

 

    OUT(lcm(2 * 3, 3 * 4, 4 * 5));

    OUT(lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6));

    OUT(lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6, 5 * 6 * 7));

}

Output:



lcm(2 * 3, 3 * 4, 4 * 5) = 60

lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6) = 120

lcm(2 * 3 * 4, 3 * 4 * 5, 4 * 5 * 6, 5 * 6 * 7) = 840



[edit] See also





  gcd(C++17)



  computes the greatest common divisor of two integers  (function template) [edit]









 





                    