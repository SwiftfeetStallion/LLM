std::frexp, std::frexpf, std::frexpl









From cppreference.com





[edit] Numerics library

Common mathematical functions

Mathematical special functions (C++17)

Mathematical constants (C++20)

Basic linear algebra algorithms (C++26)

Data-parallel types (SIMD) (C++26)

Floating-point environment (C++11)

Complex numbers

Numeric array (valarray)

Pseudo-random number generation

Bit manipulation (C++20)

Saturation arithmetic (C++26)

Factor operations



gcd(C++17)



lcm(C++17)



Interpolations



midpoint(C++20)



lerp(C++20)



Generic numeric operations



iota(C++11)

ranges::iota(C++23)

accumulate

inner_product

adjacent_difference  

partial_sum



reduce(C++17)

transform_reduce(C++17)

inclusive_scan(C++17)

exclusive_scan(C++17)

transform_inclusive_scan(C++17)

transform_exclusive_scan(C++17)



C-style checked integer arithmetic



ckd_add(C++26)

ckd_sub(C++26)



ckd_mul(C++26)







[edit] Common mathematical functions



Functions

Basic operations



abs(int)labsllabsimaxabs(C++11)  

abs(float)fabs

divldivlldivimaxdiv(C++11)



fmod

remainder(C++11)  

remquo(C++11)

fma(C++11)

fmax(C++11)

fmin(C++11)

fdim(C++11)

nannanfnanl(C++11)(C++11)(C++11)



Exponential functions



exp

exp2(C++11)

expm1(C++11)







log

log10

log1p(C++11)

log2(C++11)



Power functions



sqrt

cbrt(C++11)



hypot(C++11)

pow



Trigonometric and hyperbolic functions



sin

cos

tan

asin

acos

atan

atan2



sinh

cosh

tanh

asinh(C++11)

acosh(C++11)

atanh(C++11)







Error and gamma functions



erf(C++11)

erfc(C++11)



lgamma(C++11)

tgamma(C++11)











Nearest integer floating point operations



ceil

floor

roundlroundllround(C++11)(C++11)(C++11)



trunc(C++11)

nearbyint(C++11)

rintlrintllrint(C++11)(C++11)(C++11)



Floating point manipulation functions



ldexp

scalbnscalbln(C++11)(C++11)

ilogb(C++11)

logb(C++11)



frexp

modf

nextafternexttoward(C++11)(C++11)

copysign(C++11)



Classification and comparison



fpclassify(C++11)

isfinite(C++11)

isinf(C++11)

isnan(C++11)

isnormal(C++11)

signbit(C++11)



isgreater(C++11)

isgreaterequal(C++11)

isless(C++11)

islessequal(C++11)

islessgreater(C++11)

isunordered(C++11)



Types



div_t

ldiv_t

lldiv_t(C++11)



imaxdiv_t(C++11)

float_t(C++11)

double_t(C++11)



Macro constants



HUGE_VALFHUGE_VALHUGE_VALL(C++11)(C++11)

math_errhandlingMATH_ERRNOMATH_ERREXCEPT(C++11)  

INFINITY(C++11)

NAN(C++11)



Classification

FP_NORMALFP_SUBNORMALFP_ZEROFP_INFINITEFP_NAN(C++11)(C++11)(C++11)(C++11)(C++11)













[edit] 





 Defined in header <cmath>















(1)







float       frexp ( float num, int* exp );

double      frexp ( double num, int* exp );



long double frexp ( long double num, int* exp );

 

(until C++23)





 constexpr /* floating-point-type */

            frexp ( /* floating-point-type */ num, int* exp );

 

 (since C++23) 







 float       frexpf( float num, int* exp );

 (2) 

 (since C++11) (constexpr since C++23) 





 long double frexpl( long double num, int* exp );

 (3) 

 (since C++11) (constexpr since C++23) 





 Additional overloads (since C++11)









 Defined in header <cmath>











 template< class Integer >

double      frexp ( Integer num, int* exp );

 (A) 

 (constexpr since C++23) 







1-3) Decomposes given floating point value num into a normalized fraction and an integral exponent of two. The library provides overloads of std::frexp for all cv-unqualified floating-point types as the type of the parameter num.(since C++23)





A) Additional overloads are provided for all integer types, which are treated as double.



(since C++11)



Contents



1 Parameters

2 Return value

3 Error handling

4 Notes

5 Example

6 See also





[edit] Parameters





 num



 -



 floating-point or integer value





 exp



 -



 pointer to integer value to store the exponent to



[edit] Return value

If num is zero, returns zero and stores zero in *exp.

Otherwise (if num is not zero), if no errors occur, returns the value x in the range (-1, -0.5], [0.5, 1) and stores an integer value in *exp such that x×2(*exp)== num.

If the value to be stored in *exp is outside the range of int, the behavior is unspecified.



[edit] Error handling

This function is not subject to any errors specified in math_errhandling.

If the implementation supports IEEE floating-point arithmetic (IEC 60559),



 If num is ±0, it is returned, unmodified, and ​0​ is stored in *exp.

 If num is ±∞, it is returned, and an unspecified value is stored in *exp.

 If num is NaN, NaN is returned, and an unspecified value is stored in *exp.

 No floating-point exceptions are raised.

 If FLT_RADIX is 2 (or a power of 2), the returned value is exact, the current rounding mode is ignored.



[edit] Notes

On a binary system (where FLT_RADIX is 2), std::frexp may be implemented as 



{

    *exp = (value == 0) ? 0 : (int)(1 + std::logb(value));

    return std::scalbn(value, -(*exp));

}

The function std::frexp, together with its dual, std::ldexp, can be used to manipulate the representation of a floating-point number without direct bit manipulations.

The additional overloads are not required to be provided exactly as (A). They only need to be sufficient to ensure that for their argument num of integer type, std::frexp(num, exp) has the same effect as std::frexp(static_cast<double>(num), exp).



[edit] Example

Compares different floating-point decomposition functions:Run this code

#include <cmath>

#include <iostream>

#include <limits>

 

int main()

{

    double f = 123.45;

    std::cout << "Given the number " << f << " or " << std::hexfloat

              << f << std::defaultfloat << " in hex,\n";

 

    double f3;

    double f2 = std::modf(f, &f3);

    std::cout << "modf() makes " << f3 << " + " << f2 << '\n';

 

    int i;

    f2 = std::frexp(f, &i);

    std::cout << "frexp() makes " << f2 << " * 2^" << i << '\n';

 

    i = std::ilogb(f);

    std::cout << "logb()/ilogb() make " << f / std::scalbn(1.0, i)

              << " * " << std::numeric_limits<double>::radix

              << "^" << std::ilogb(f) << '\n';

}

Possible output:



Given the number 123.45 or 0x1.edccccccccccdp+6 in hex,

modf() makes 123 + 0.45

frexp() makes 0.964453 * 2^7

logb()/ilogb() make 1.92891 * 2^6



[edit] See also





  ldexpldexpfldexpl(C++11)(C++11)



  multiplies a number by 2 raised to an integral power  (function) [edit]





  logblogbflogbl(C++11)(C++11)(C++11)



  extracts exponent of the number  (function) [edit]





  ilogbilogbfilogbl(C++11)(C++11)(C++11)



  extracts exponent of the number  (function) [edit]





  modfmodffmodfl(C++11)(C++11)



  decomposes a number into integer and fractional parts  (function) [edit]





 C documentation for frexp









 





                    