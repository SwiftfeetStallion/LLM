Replacement functions









From cppreference.com





[edit] C++ language



General topics



Preprocessor

Comments



Keywords

Escape sequences



Flow control

Conditional execution statements



if



switch



Iteration statements (loops)



for

range-for (C++11)



while

do-while



Jump statements



continue - break



goto - return



Functions

Function declaration

Lambda function expression

inline specifier

Dynamic exception specifications (until C++17*)

noexcept specifier (C++11)

Exceptions



throw-expression

try block







catch handler



Namespaces



Namespace declaration  



Namespace aliases



Types



Fundamental types

Enumeration types

Function types



Class/struct types

Union types







Specifiers



const/volatile

decltype (C++11)

auto (C++11)



constexpr (C++11)

consteval (C++20)

constinit (C++20)



Storage duration specifiers

Initialization



Default-initialization

Value-initialization

Zero-initialization

Copy-initialization

Direct-initialization



Aggregate initialization

List-initialization (C++11)  

Constant initialization

Reference initialization















Expressions



Value categories

Order of evaluation



Operators

Operator precedence



Alternative representations

Literals

Boolean - Integer - Floating-point

Character - String - nullptr (C++11)

User-defined (C++11)

Utilities

Attributes (C++11)

Types

typedef declaration

Type alias declaration (C++11)

Casts



Implicit conversions

static_cast

const_cast



Explicit conversions

dynamic_cast

reinterpret_cast



Memory allocation



new expression



delete expression



Classes



Class declaration

Constructors

this pointer



Access specifiers

friend specifier







Class-specific function properties



Virtual function

override specifier (C++11)  

final specifier (C++11)



explicit (C++11)

static







Special member functions



Default constructor

Copy constructor

Move constructor (C++11)



Copy assignment

Move assignment (C++11)

Destructor



Templates



Class template

Function template



Template specialization

Parameter packs (C++11)



Miscellaneous



Inline assembly



History of C++





[edit]  Functions



Declarations

Function declaration

Function parameter list

Function definition

Function contract specifiers (C++26)

Default arguments

Variadic arguments

inline specifier

Lambda expressions (C++11)

Coroutines (C++20)

Replacement functions

Function calls

Argument-Dependent Lookup (ADL)

Function-call operator

Function objects

Overloading

Overload resolution

Operator overloading

Address of an overload set



[edit] 

Certain functions for which a definition is supplied by the implementation are replaceable ﻿. A C++ program may provide a definition with the signature of a replaceable function, called a replacement function ﻿. The replacement function, if provided, is used instead of the default version supplied by the implementation. Such replacement occurs prior to program startup.

If a declaration of the replacement function does not satisfy any of the following conditions, the program is ill-formed, no diagnostic is required:



 It is not inline.

 It is attached to the global module.

 It has C++ language linkage.

 It has the same return type as the replaceable function.

 If the replaceable function is declared in a standard library header, it would be valid as a redeclaration of the declaration in that header.







 Core language

It is implementation-defined whether the contract-violation handler ::handle_contract_violation is replaceable.





(since C++26)



[edit] Standard library

The following standard library functions are replaceable, and the description of function semantics apply to both the default version defined by the C++ standard library and the replacement function defined by the program:







  operator newoperator new[]



  allocation functions  (function) [edit]





  operator deleteoperator delete[]



  deallocation functions  (function) [edit]





  is_debugger_present(C++26)



  checks whether a program is running under the control of a debugger  (function) [edit]





[edit] Example

Uses a replacement allocation function:Run this code

#include <cstddef>

#include <new>

#include <print>

 

// replacement function

void* operator new(std::size_t count)

{

    std::print("Replaced!");

    return nullptr;

}

 

int main()

{

    int* ptr = new int; // invokes the replacement version defined by the program

}

Output:



Replaced!







 





                    