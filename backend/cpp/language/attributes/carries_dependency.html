C++ attribute: carries_dependency (since C++11)(removed in C++26)









From cppreference.com





[edit] C++ language



General topics



Preprocessor

Comments



Keywords

Escape sequences



Flow control

Conditional execution statements



if



switch



Iteration statements (loops)



for

range-for (C++11)



while

do-while



Jump statements



continue - break



goto - return



Functions

Function declaration

Lambda function expression

inline specifier

Dynamic exception specifications (until C++17*)

noexcept specifier (C++11)

Exceptions



throw-expression

try block







catch handler



Namespaces



Namespace declaration  



Namespace aliases



Types



Fundamental types

Enumeration types

Function types



Class/struct types

Union types







Specifiers



const/volatile

decltype (C++11)

auto (C++11)



constexpr (C++11)

consteval (C++20)

constinit (C++20)



Storage duration specifiers

Initialization



Default-initialization

Value-initialization

Zero-initialization

Copy-initialization

Direct-initialization



Aggregate initialization

List-initialization (C++11)  

Constant initialization

Reference initialization















Expressions



Value categories

Order of evaluation



Operators

Operator precedence



Alternative representations

Literals

Boolean - Integer - Floating-point

Character - String - nullptr (C++11)

User-defined (C++11)

Utilities

Attributes (C++11)

Types

typedef declaration

Type alias declaration (C++11)

Casts



Implicit conversions

static_cast

const_cast



Explicit conversions

dynamic_cast

reinterpret_cast



Memory allocation



new expression



delete expression



Classes



Class declaration

Constructors

this pointer



Access specifiers

friend specifier







Class-specific function properties



Virtual function

override specifier (C++11)  

final specifier (C++11)



explicit (C++11)

static







Special member functions



Default constructor

Copy constructor

Move constructor (C++11)



Copy assignment

Move assignment (C++11)

Destructor



Templates



Class template

Function template



Template specialization

Parameter packs (C++11)



Miscellaneous



Inline assembly



History of C++





[edit] Declarations





Overview

Declaration syntax

decl-specifier-seq

Declarator

Conflicting declarations

Specifiers

typedef

inline

virtual function specifier

explicit function specifier

friend

constexpr(C++11)

consteval(C++20)

constinit(C++20)

Storage class specifiers

Translation-unit-local (C++20)

class/struct

union

enum

decltype(C++11)

auto(C++11)

alignas(C++11)

constvolatile

Pack indexing specifier (C++26)    

Elaborated type specifier

Attributes (C++11)



Declarators

Reference

Pointer

Array

Block declarations

Simple-declaration

  →Structured binding declaration (C++17)

Alias declaration (C++11)

Namespace alias definition

using declaration

using directive

static_assert declaration (C++11)

asm declaration

Opaque enum declaration (C++11)

Other declarations

Namespace definition

Function declaration

Class template declaration

Function template declaration

Explicit template instantiation (C++11)

Explicit template specialization

Linkage specification

Attribute declaration (C++11)

Empty declaration









[edit] Attributes

assume(C++23)

carries_dependency(C++11)(until C++26)

deprecated(C++14)

fallthrough(C++17)

indeterminate(C++26)

likely(C++20)

maybe_unused(C++17)

nodiscard(C++17)

noreturn(C++11)

no_unique_address(C++20)

optimize_for_synchronized(TM TS)

unlikely(C++20)

[edit] 

Indicates that dependency chain in release-consume std::memory_order propagates in and out of the function, which allows the compiler to skip unnecessary memory fence instructions.



Contents



1 Syntax

2 Explanation

3 Example

4 References

5 See also





[edit] Syntax











 [[carries_dependency]]

















[edit] Explanation

This attribute may appear in two situations:



1) it may apply to the parameter declarations of a function or lambda-expressions, in which case it indicates that initialization of the parameter carries dependency into lvalue-to-rvalue conversion of that object.

2) It may apply to the function declaration as a whole, in which case it indicates that the return value carries dependency to the evaluation of the function call expression.

This attribute must appear on the first declaration of a function or one of its parameters in any translation unit. If it is not used on the first declaration of a function or one of its parameters in another translation unit, the program is ill-formed; no diagnostic required.



[edit] Example

Adapted almost without change from SO.Run this code

#include <atomic>

#include <iostream>

 

void print(int* val)

{

    std::cout << *val << std::endl;

}

 

void print2(int* val [[carries_dependency]])

{

    std::cout << *val << std::endl;

}

 

int main()

{

    int x{42};

    std::atomic<int*> p = &x;

    int* local = p.load(std::memory_order_consume);

 

    if (local)

    {

        // The dependency is explicit, so the compiler knows that local is

        // dereferenced, and that it must ensure that the dependency chain

        // is preserved in order to avoid a fence (on some architectures).

        std::cout << *local << std::endl;

    }

 

    if (local)

    {

        // The definition of print is opaque (assuming it is not inlined),

        // so the compiler must issue a fence in order to ensure that

        // reading *p in print returns the correct value.

        print(local);

    }

 

    if (local)

    {

        // The compiler can assume that although print2 is also opaque then

        // the dependency from the parameter to the dereferenced value is

        // preserved in the instruction stream, and no fence is necessary (on

        // some architectures). Obviously, the definition of print2 must actually

        // preserve this dependency, so the attribute will also impact the

        // generated code for print2.

        print2(local);

    }

}

Possible output:



42

42

42



[edit] References



 C++23 standard (ISO/IEC 14882:2024): 



 9.12.4 Carries dependency attribute [dcl.attr.depend] 









 C++20 standard (ISO/IEC 14882:2020): 



 9.12.3 Carries dependency attribute [dcl.attr.depend] 









 C++17 standard (ISO/IEC 14882:2017): 



 10.6.3 Carries dependency attribute [dcl.attr.depend] 









 C++14 standard (ISO/IEC 14882:2014): 



 7.6.4 Carries dependency attribute [dcl.attr.depend] 









 C++11 standard (ISO/IEC 14882:2011): 



 7.6.4 Carries dependency attribute [dcl.attr.depend] 







[edit] See also





  kill_dependency(C++11)(deprecated in C++26)



  removes the specified object from the std::memory_order_consume dependency tree  (function template) [edit]









 





                    