C++ attribute: no_unique_address (since C++20)









From cppreference.com





[edit] C++ language



General topics



Preprocessor

Comments



Keywords

Escape sequences



Flow control

Conditional execution statements



if



switch



Iteration statements (loops)



for

range-for (C++11)



while

do-while



Jump statements



continue - break



goto - return



Functions

Function declaration

Lambda function expression

inline specifier

Dynamic exception specifications (until C++17*)

noexcept specifier (C++11)

Exceptions



throw-expression

try block







catch handler



Namespaces



Namespace declaration  



Namespace aliases



Types



Fundamental types

Enumeration types

Function types



Class/struct types

Union types







Specifiers



const/volatile

decltype (C++11)

auto (C++11)



constexpr (C++11)

consteval (C++20)

constinit (C++20)



Storage duration specifiers

Initialization



Default-initialization

Value-initialization

Zero-initialization

Copy-initialization

Direct-initialization



Aggregate initialization

List-initialization (C++11)  

Constant initialization

Reference initialization















Expressions



Value categories

Order of evaluation



Operators

Operator precedence



Alternative representations

Literals

Boolean - Integer - Floating-point

Character - String - nullptr (C++11)

User-defined (C++11)

Utilities

Attributes (C++11)

Types

typedef declaration

Type alias declaration (C++11)

Casts



Implicit conversions

static_cast

const_cast



Explicit conversions

dynamic_cast

reinterpret_cast



Memory allocation



new expression



delete expression



Classes



Class declaration

Constructors

this pointer



Access specifiers

friend specifier







Class-specific function properties



Virtual function

override specifier (C++11)  

final specifier (C++11)



explicit (C++11)

static







Special member functions



Default constructor

Copy constructor

Move constructor (C++11)



Copy assignment

Move assignment (C++11)

Destructor



Templates



Class template

Function template



Template specialization

Parameter packs (C++11)



Miscellaneous



Inline assembly



History of C++





[edit] Declarations





Overview

Declaration syntax

decl-specifier-seq

Declarator

Conflicting declarations

Specifiers

typedef

inline

virtual function specifier

explicit function specifier

friend

constexpr(C++11)

consteval(C++20)

constinit(C++20)

Storage class specifiers

Translation-unit-local (C++20)

class/struct

union

enum

decltype(C++11)

auto(C++11)

alignas(C++11)

constvolatile

Pack indexing specifier (C++26)    

Elaborated type specifier

Attributes (C++11)



Declarators

Reference

Pointer

Array

Block declarations

Simple-declaration

  →Structured binding declaration (C++17)

Alias declaration (C++11)

Namespace alias definition

using declaration

using directive

static_assert declaration (C++11)

asm declaration

Opaque enum declaration (C++11)

Other declarations

Namespace definition

Function declaration

Class template declaration

Function template declaration

Explicit template instantiation (C++11)

Explicit template specialization

Linkage specification

Attribute declaration (C++11)

Empty declaration









[edit] Attributes

assume(C++23)

carries_dependency(C++11)(until C++26)

deprecated(C++14)

fallthrough(C++17)

indeterminate(C++26)

likely(C++20)

maybe_unused(C++17)

nodiscard(C++17)

noreturn(C++11)

no_unique_address(C++20)

optimize_for_synchronized(TM TS)

unlikely(C++20)

[edit] 

Allows this data member to be overlapped with other non-static data members or base class subobjects of its class.



Contents



1 Syntax

2 Explanation

3 Notes

4 Example

5 References





[edit] Syntax











 [[no_unique_address]]

















[edit] Explanation

Applies to the name being declared in the declaration of a non-static data member that is not a bit-field.

Makes this member subobject potentially-overlapping, i.e., allows this member to be overlapped with other non-static data members or base class subobjects of its class. This means that if the member has an empty class type (e.g. stateless allocator), the compiler may optimize it to occupy no space, just like if it were an empty base. If the member is not empty, any tail padding in it may be also reused to store other data members.



[edit] Notes

[[no_unique_address]] is ignored by MSVC even in C++20 mode; instead, [[msvc::no_unique_address]] is provided.



[edit] Example

Run this code

#include <boost/type_index.hpp>

#include <iostream>

 

struct Empty {}; // The size of any object of empty class type is at least 1

static_assert(sizeof(Empty) >= 1);

 

struct X

{

    int i;

    Empty e; // At least one more byte is needed to give ‘e’ a unique address

};

static_assert(sizeof(X) >= sizeof(int) + 1);

 

struct Y

{

    int i;

    [[no_unique_address]] Empty e; // Empty member optimized out

};

static_assert(sizeof(Y) >= sizeof(int));

 

struct Z

{

    char c;

    // e1 and e2 cannot share the same address because they have the

    // same type, even though they are marked with [[no_unique_address]].

    // However, either may share address with ‘c’.

    [[no_unique_address]] Empty e1, e2;

};

static_assert(sizeof(Z) >= 2);

 

struct W

{

    char c[2];

    // e1 and e2 cannot have the same address, but one of

    // them can share with c[0] and the other with c[1]:

    [[no_unique_address]] Empty e1, e2;

};

static_assert(sizeof(W) >= 2);

 

template <typename T>

void print_size_of()

{

    using boost::typeindex::type_id;

    std::cout << "sizeof(" << type_id<T>() << ") == " << sizeof(T) << '\n';

}

 

int main()

{

    print_size_of<Empty>();

    print_size_of<int>();

    print_size_of<X>();

    print_size_of<Y>();

    print_size_of<Z>();

    print_size_of<W>();

}

Possible output:



sizeof(Empty) == 1

sizeof(int) == 4

sizeof(X) == 8

sizeof(Y) == 4

sizeof(Z) == 2

sizeof(W) == 3



[edit] References



 C++23 standard (ISO/IEC 14882:2024): 



 9.12.11 No unique address attribute [dcl.attr.nouniqueaddr] 









 C++20 standard (ISO/IEC 14882:2020): 



 9.12.10 No unique address attribute [dcl.attr.nouniqueaddr] 











 





                    