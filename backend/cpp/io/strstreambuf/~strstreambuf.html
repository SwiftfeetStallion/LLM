std::strstreambuf::~strstreambuf









From cppreference.com





[edit] Input/output library

I/O manipulators

Print functions (C++23)

C-style I/O

Buffers

basic_streambuf

basic_filebuf

basic_stringbuf

basic_spanbuf(C++23)

strstreambuf(C++98/26*)

basic_syncbuf(C++20)

Streams

Abstractions

ios_base

basic_ios

basic_istream

basic_ostream

basic_iostream

File I/O

basic_ifstream

basic_ofstream

basic_fstream

String I/O

basic_istringstream

basic_ostringstream

basic_stringstream

Array I/O

basic_ispanstream(C++23)

basic_ospanstream(C++23)

basic_spanstream(C++23)

istrstream(C++98/26*)

ostrstream(C++98/26*)

strstream(C++98/26*)

Synchronized Output

basic_osyncstream(C++20)

Types

streamoff

streamsize

fpos

Error category interface

iostream_category(C++11)

io_errc(C++11)

[edit] std::strstreambuf

Public member functions

strstreambuf::strstreambuf

strstreambuf::~strstreambuf

strstreambuf::freeze

strstreambuf::str

strstreambuf::pcount

Protected member functions

strstreambuf::underflow

strstreambuf::pbackfail

strstreambuf::overflow

strstreambuf::setbuf

strstreambuf::seekoff

strstreambuf::seekpos

[edit] 





 virtual ~strstreambuf();

 

 (deprecated in C++98) (removed in C++26) 







Destroys a std::strstreambuf object. if the object is managing a dynamically-allocated buffer (the buffer state is "allocated") and if the object is not frozen, then deallocates the buffer using the deallocation function provided at construction or delete[] if none was provided.



[edit] Parameters

(none)



[edit] Notes

This destructor is typically called by the destructor of std::strstream.

If str() was called on a dynamic strstream and freeze(false) was not called after that, this destructor leaks memory.



[edit] Example

Run this code

#include <iostream>

#include <strstream>

 

void* my_alloc(size_t n)

{

    std::cout << "my_alloc(" << n << ") called\n";

    return new char[n];

}

 

void my_free(void* p)

{

    std::cout << "my_free() called\n";

    delete[] (char*)p;

}

 

int main()

{

    {

        std::strstreambuf buf(my_alloc, my_free);

        std::ostream s(&buf);

        s << 1.23 << std::ends;

        std::cout << buf.str() << '\n';

        buf.freeze(false);

    } // destructor called here, buffer deallocated

 

    {

        std::strstreambuf buf(my_alloc, my_free);

        std::ostream s(&buf);

        s << 1.23 << std::ends;

        std::cout << buf.str() << '\n';

//      buf.freeze(false);

    } // destructor called here, memory leak!

}

Output:



my_alloc(4096) called

1.23

my_free() called

my_alloc(4096) called

1.23







 





                    