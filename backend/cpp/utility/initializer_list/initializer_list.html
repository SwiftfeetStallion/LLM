std::initializer_list[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] std::initializer_list

Member functions

initializer_list::initializer_list

Capacity

initializer_list::size

Iterators

initializer_list::begin

initializer_list::end

Non-member functions

begin(std::initializer_list)

end(std::initializer_list)

[edit] 





initializer_list() noexcept;

 

(since C++11) (constexpr since C++14)







Constructs an empty initializer list.



Contents



1 Parameters

2 Complexity

3 Notes

4 Example





[edit] Parameters

(none)



[edit] Complexity

Constant



[edit] Notes

Despite a lack of constructors, it is possible to create non-empty initializer lists.  Instances of std::initializer_list are implicitly constructed when:



 a braced-init-list is used in list-initialization, including function-call list initialization and assignment expressions (not to be confused with constructor initializer lists)

 a braced-init-list is bound to auto, including in a ranged for loop



[edit] Example

Run this code

#include <initializer_list>

#include <iostream>

 

int main()

{

    std::initializer_list<int> empty_list;

    std::cout << "empty_list.size(): " << empty_list.size() << '\n';

 

    // create initializer lists using list-initialization

    std::initializer_list<int> digits{1, 2, 3, 4, 5};

    std::cout << "digits.size(): " << digits.size() << '\n';

 

    // special rule for auto means 'fractions' has the

    // type std::initializer_list<double>

    auto fractions = {3.14159, 2.71828};

    std::cout << "fractions.size(): " << fractions.size() << '\n';

 

    // create constexpr initializer list (since C++14)

    static constexpr auto ab = {'a', 'b'};

    static_assert(ab.size() == 2 and *ab.begin() == 'a');

}

Output:



empty_list.size(): 0

digits.size(): 5

fractions.size(): 2







 





                    