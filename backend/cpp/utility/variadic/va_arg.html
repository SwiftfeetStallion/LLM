va_arg









From cppreference.com





[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] Variadic functions

va_start

va_arg

va_copy(C++11)

va_end

va_list

[edit] 





 Defined in header <cstdarg>











 T va_arg( std::va_list ap, T );

 

 







The va_arg macro expands to an expression of type T that corresponds to the next parameter from the va_list ap.

Prior to calling va_arg, ap must be initialized by a call to either va_start or va_copy, with no intervening call to va_end. Each invocation of the va_arg macro modifies ap to point to the next variable argument.

If the type of the next argument in ap (after promotions) is not compatible with T, the behavior is undefined, unless:



 one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types; or

 one type is pointer to void and the other is a pointer to a character type (char, signed char, or unsigned char).



If va_arg is called when there are no more arguments in ap, the behavior is undefined.



Contents



1 Parameters

2 Expanded value

3 Example

4 See also





[edit] Parameters





 ap



 -



 an instance of the va_list type





 T



 -



 the type of the next parameter in ap



[edit] Expanded value

The next variable parameter in ap.



[edit] Example

Run this code

#include <cstdarg>

#include <cstdio>

#include <iostream>

 

void print_variance(std::size_t count, const char* fmt, ...)

{

    double sum = 0;

    double sum_sq = 0;

    std::va_list args;

    va_start(args, fmt);

    for (std::size_t i = count; i--;)

    {

        double num = va_arg(args, double);

        sum += num;

        sum_sq += num*num;

    }

    va_end(args);

    std::printf(fmt, sum_sq / count - (sum / count) * (sum / count));

}

 

void nano_printf(const char* fmt, ...)

{

    std::va_list args;

    va_start(args, fmt);

 

    for (const char* p = fmt; *p != '\0'; ++p)

    {

        switch (*p)

        {

        case '%':

            switch (*++p) // read format symbol

            {

                case 'i':

                    std::cout << va_arg(args, int);

                    continue;

                case 'f':

                    std::cout << va_arg(args, double);

                    continue;

                case 's':

                    std::cout << va_arg(args, const char*);

                    continue;

                case 'c':

                    std::cout << static_cast<char>(va_arg(args, int));

                    continue;

                case '%':

                    std::cout << '%';

                    continue;

                /* ...more cases... */

            }

            break; // format error...

        case '\n':

            std::cout << '\n';

            continue;

        case '\t':

            std::cout << '\t';

            continue;

        /* ...more cases... */

        }

        std::cout << *p;

    }

 

    va_end(args);

}

 

int main()

{

    print_variance(4, "%f\n", 25.0, 27.3, 26.9, 25.7);

    nano_printf("Args: %i%% %c%f %s\n", 42, '#', 3.14, "C++");

}

Output:



0.846875

Args: 42% #3.14 C++



[edit] See also





  va_start



  enables access to variadic function arguments  (function macro) [edit]





  va_copy(C++11)



  makes a copy of the variadic function arguments  (function macro) [edit]





  va_end



  ends traversal of the variadic function arguments  (function macro) [edit]





 C documentation for va_arg









 





                    