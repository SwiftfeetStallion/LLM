std::expected[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] std::expected

Member functions

expected::expected

expected::~expected

expected::operator=

Observers

expected::operator->expected::operator*

expected::operator boolexpected::has_value

expected::value

expected::error

expected::value_or

expected::error_or

Monadic operations

expected::and_then

expected::or_else

expected::transform

expected::transform_error

Modifiers

expected::emplace

expected::swap

Non-member functions

operator==(std::expected)

swap(std::expected)

Helper classes

unexpected

bad_expected_access

unexpect_tunexpect

[edit] 





 Primary template









 constexpr const T* operator->() const noexcept;

 (1) 

 (since C++23) 





 constexpr T* operator->() noexcept;

 (2) 

 (since C++23) 





 constexpr const T& operator*() const& noexcept;

 (3) 

 (since C++23) 





 constexpr T& operator*() & noexcept;

 (4) 

 (since C++23) 





 constexpr const T&& operator*() const&& noexcept;

 (5) 

 (since C++23) 





 constexpr T&& operator*() && noexcept;

 (6) 

 (since C++23) 





 void partial specialization









 constexpr void operator*() const noexcept;

 (7) 

 (since C++23) 







Accesses the expected value contained in *this.



1,2) Returns a pointer to the expected value.

3-6) Returns a reference to the expected value.

7) Returns nothing.







If has_value() is false, the behavior is undefined.





(until C++26)



If has_value() is false:



 If the implementation is hardened, a contract violation occurs. Moreover, if the contract-violation handler returns under “observe” evaluation semantic, the behavior is undefined.

 If the implementation is not hardened, the behavior is undefined.





(since C++26)



Contents



1 Return value

2 Notes

3 Example

4 See also





[edit] Return value

1,2) std::addressof(val ﻿)

3,4) val

5,6) std::move(val ﻿)

[edit] Notes

These operators do not check whether the optional represents an expected value, users can do so manually by using has_value() or operator bool(). Alternatively, if checked access is needed, value() or value_or() may be used.



[edit] Example

Run this code

#include <cassert>

#include <expected>

#include <iomanip>

#include <iostream>

#include <string>

 

int main()

{

    using namespace std::string_literals;

 

    std::expected<int, std::string> ex1 = 6;

    assert(*ex1 == 6);

 

    *ex1 = 9;

    assert(*ex1 == 9);

 

    // *ex1 = "error"s; // error, ex1 contains an expected value of type int

    ex1 = std::unexpected("error"s);

    // *ex1 = 13; // UB, ex1 contains an unexpected value

    assert(ex1.value_or(42) == 42);

 

    std::expected<std::string, bool> ex2 = "Moon"s;

    std::cout << "ex2: " << std::quoted(*ex2) << ", size: " << ex2->size() << '\n';

 

    // You can "take" the expected value by calling operator* on an std::expected rvalue

 

    auto taken = *std::move(ex2);

    std::cout << "taken " << std::quoted(taken) << "\n"

                 "ex2: " << std::quoted(*ex2) << ", size: " << ex2->size() << '\n';

}

Possible output:



ex2: "Moon", size: 4

taken "Moon"

ex2: "", size: 0



[edit] See also





  value



  returns the expected value  (public member function) [edit]





  value_or



  returns the expected value if present, another value otherwise  (public member function) [edit]





  operator boolhas_value



  checks whether the object contains an expected value  (public member function) [edit]





  error



  returns the unexpected value  (public member function) [edit]









 





                    