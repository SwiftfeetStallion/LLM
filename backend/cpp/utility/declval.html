std::declval









From cppreference.com





[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] 





 Defined in header <utility>















template< class T >

typename std::add_rvalue_reference<T>::type declval() noexcept;

 

(since C++11) (until C++14) (unevaluated-only)





 template< class T >

std::add_rvalue_reference_t<T> declval() noexcept;

 

 (since C++14) (unevaluated-only) 









Helper template for writing expressions that appear in unevaluated contexts, typically the operand of decltype. In unevaluated context, this helper template converts any type T (which may be an incomplete type) to an expression of that type, making it possible to use member functions of T without the need to go through constructors.

std::declval can only be used in unevaluated contexts and is not required to be defined; it is an error to evaluate an expression that contains this function. Formally, the program is ill-formed if this function is odr-used.



Contents



1 Parameters

2 Return value

3 Notes

4 Possible implementation

5 Example

6 See also





[edit] Parameters

(none)



[edit] Return value

Cannot be evaluated and thus never returns a value. The return type is T&& (reference collapsing rules apply) unless T is (possibly cv-qualified) void, in which case the return type is T.



[edit] Notes

std::declval is commonly used in templates where acceptable template parameters may have no constructor in common, but have the same member function whose return type is needed.



[edit] Possible implementation







template<typename T>

typename std::add_rvalue_reference<T>::type declval() noexcept

{

    static_assert(false, "declval not allowed in an evaluated context");

}



[edit] Example

Run this code

#include <iostream>

#include <utility>

 

struct Default

{

    int foo() const { return 1; }

};

 

struct NonDefault

{

    NonDefault() = delete;

    int foo() const { return 1; }

};

 

int main()

{

    decltype(Default().foo())               n1 = 1;     // type of n1 is int

    decltype(std::declval<Default>().foo()) n2 = 1;     // same

 

//  decltype(NonDefault().foo())               n3 = n1; // error: no default constructor

    decltype(std::declval<NonDefault>().foo()) n3 = n1; // type of n3 is int

 

    std::cout << "n1 = " << n1 << '\n'

              << "n2 = " << n2 << '\n'

              << "n3 = " << n3 << '\n';

}

Output:



n1 = 1

n2 = 1

n3 = 1



[edit] See also





  decltype specifier(C++11)



  obtains the type of an expression or an entity[edit]





  result_ofinvoke_result(C++11)(removed in C++20)(C++17)



  deduces the result type of invoking a callable object with a set of arguments  (class template) [edit]









 





                    