std::ignore









From cppreference.com





[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] std::tuple

Member functions

tuple::tuple

tuple::operator=

tuple::swap

Non-member functions

make_tuple

tie

forward_as_tuple

tuple_cat

operator==operator!=operator<operator<=operator>operator>=operator<=>(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)(C++20)

swap(std::tuple)

get(std::tuple)

Helper concepts

tuple-like(C++23)

Helper classes

tuple_size<std::tuple>

tuple_element<std::tuple>

uses_allocator<std::tuple>

basic_common_reference<std::tuple>(C++23)

common_type<std::tuple>(C++23)

formatter<std::tuple>(C++23)

ignore

Deduction guides(C++17)

[edit] 





 Defined in header <tuple>











 Defined in header <utility>















(1)







const /*ignore-type*/ ignore;

 

(since C++11) (until C++14)





 constexpr /*ignore-type*/ ignore;

 

 (since C++14) (inline since c++17) 











(2)







struct /*ignore-type*/

{

    template< class T >

    const /*ignore-type*/& operator=( const T& ) const noexcept

    {

        return *this;

    }



};

 

(since C++11) (until C++14) (exposition only*)





 struct /*ignore-type*/

{

    template< class T >

    constexpr const /*ignore-type*/& operator=( const T& ) const noexcept

    {

        return *this;

    }



};

 

 (since C++14) (exposition only*) 









1) An object such that any value can be assigned to it with no effect.

2) The type of std::ignore.

Contents



1 Notes

2 Example

3 Defect reports

4 See also





[edit] Notes

A void expression or a volatile bit-field value cannot be assigned to std::ignore.

std::ignore is intended for use with std::tie when unpacking a std::tuple, as a placeholder for the arguments that are not used, but can be used for any unwanted assignment.

Some code guides recommend using std::ignore to avoid warnings from unused return values of [[nodiscard]] functions, even though an assignment isn't required.

For ignoring values not requiring assignment, one may cast to void. For variables that have names, but whose value is unused, one may cast those to void or declare those variables with [[maybe_unused]].



[edit] Example

 Demonstrates the use of std::ignore together with a [[nodiscard]] function.

 Unpacks a std::pair<iterator, bool> returned by std::set::insert(), but only saves the boolean.



Run this code

#include <iostream>

#include <set>

#include <string>

#include <tuple>

 

[[nodiscard]] int dontIgnoreMe()

{

    return 42;

}

 

int main()

{

    std::ignore = dontIgnoreMe();

 

    std::set<std::string> set_of_str;

    if (bool inserted{false};

        std::tie(std::ignore, inserted) = set_of_str.insert("Test"),

        inserted)

        std::cout << "Value was inserted successfully.\n";

}

Output:



Value was inserted successfully.



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 2773



C++14



std::tuple was made constexpr but std::ignore was not yet



made constexpr





P2968R2



C++11



the behavior of std::ignore outside of std::tie was not formally specified



made fully specified



[edit] See also





  tie(C++11)



  creates a tuple of lvalue references or unpacks a tuple into individual objects  (function template) [edit]









 





                    