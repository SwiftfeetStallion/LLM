std::tuple_element[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] std::pair

Member functions

pair::pair

pair::operator=

pair::swap(C++11)

Non-member functions

make_pair

operator==operator!=operator<operator<=operator>operator>=operator<=>(until C++20)(until C++20)(until C++20)(until C++20)(until C++20)(C++20)

swap(std::pair)(C++11)

get(std::pair)(C++11)

Helper classes

tuple_size<std::pair>(C++11)

tuple_element<std::pair>(C++11)

basic_common_reference<std::pair>(C++23)

common_type<std::pair>(C++23)

formatter<std::pair>(C++23)

piecewise_construct_t(C++11)

Deduction guides(C++17)

[edit] 





 Defined in header <utility>











 template< std::size_t I, class T1, class T2 >

struct tuple_element<I, std::pair<T1, T2>>;

 

 (since C++11) 







The partial specializations of std::tuple_element for pairs provide compile-time access to the types of the pair's elements, using tuple-like syntax. The program is ill-formed if I >= 2.



Contents



1 Member types

2 Possible implementation

3 Example

4 Defect reports

5 See also





[edit] Member types





 Member type



 Definition





 type



 T1 if I == 0T2 if I == 1





[edit] Possible implementation







template<std::size_t I, typename T>

struct tuple_element;

 

template<std::size_t I, typename T1, typename T2>

struct tuple_element<I, std::pair<T1, T2>>

{

    static_assert(I < 2, "std::pair has only 2 elements!");

};

 

template<typename T1, typename T2>

struct tuple_element<0, std::pair<T1, T2>>

{

    using type = T1;

};

 

template<typename T1, typename T2>

struct tuple_element<1, std::pair<T1, T2>>

{

    using type = T2;

};



[edit] Example

Run this code

#include <iostream>

#include <string>

#include <tuple>

 

namespace detail

{

    template<std::size_t>

    struct index_tag { constexpr explicit index_tag() = default; };

 

    template<class T, class U>

    constexpr T get_val_dispatch(std::pair<T, U> const& pair, index_tag<0>)

    {

        return pair.first;

    }

 

    template<class T, class U>

    constexpr U get_val_dispatch(std::pair<T, U> const& pair, index_tag<1>)

    {

        return pair.second;

    }

} // namespace detail

 

template<std::size_t N, class T, class U>

auto constexpr get_val(std::pair<T, U> const& pair)

    -> typename std::tuple_element<N, std::pair<T, U>>::type

{

    return detail::get_val_dispatch(pair, detail::index_tag<N>{});

}

 

int main()

{

    auto var = std::make_pair(1, std::string{"one"});

 

    std::cout << get_val<0>(var) << " = " << get_val<1>(var);

}

Output:



1 = one



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 2974



C++11



out-of-bounds index referred the undefined primary template



made ill-formed (hard error)



[edit] See also





 Structured binding (C++17)



  binds the specified names to sub-objects or tuple elements of the initializer[edit]





  std::tuple_element<std::tuple>(C++11)



  obtains the type of the specified element  (class template specialization) [edit]





  std::tuple_element<std::array>(C++11)



  obtains the type of the elements of array  (class template specialization) [edit]





  std::tuple_element<std::ranges::subrange>(C++20)



  obtains the type of the iterator or the sentinel of a std::ranges::subrange  (class template specialization) [edit]





  std::tuple_size<std::pair>(C++11)



  obtains the size of a pair  (class template specialization) [edit]









 





                    