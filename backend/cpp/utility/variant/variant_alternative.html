std::variant_alternative, std::variant_alternative_t









From cppreference.com





[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] std::variant

Member functions

variant::variant

variant::~variant

variant::operator=

Observers

variant::index

variant::valueless_by_exception

Modifiers

variant::emplace

variant::swap

Visitation

variant::visit(C++26)

Non-member functions

visit(std::variant)

holds_alternative

get(std::variant)

get_if

operator==operator!=operator<operator<=operator>operator>=operator<=>(C++20)

swap(std::variant)

Helper classes

monostate

bad_variant_access

variant_size

variant_alternative

hash<std::variant>

Helper objects

variant_npos

[edit] 





 Defined in header <variant>











 template <std::size_t I, class T>

struct variant_alternative; /* undefined */

 (1) 

 (since C++17) 





 template <std::size_t I, class... Types>

struct variant_alternative<I, variant<Types...>>;

 (2) 

 (since C++17) 





 template <std::size_t I, class T> class variant_alternative<I, const T>;

 (3) 

 (since C++17) 





 template <std::size_t I, class T>

class variant_alternative<I, volatile T>;

template <std::size_t I, class T>



class variant_alternative<I, const volatile T>;

 (3) 

 (since C++17) (deprecated in C++20) 







Provides compile-time indexed access to the types of the alternatives of the possibly cv-qualified variant, combining cv-qualifications of the variant (if any) with the cv-qualifications of the alternative.

Formally, 



2) meets the TransformationTrait requirements with a member typedef type equal to the type of the alternative with index I

3) meets the TransformationTrait requirements with a member typedef type that names, respectively, std::add_const_t<std::variant_alternative_t<I,T>>, std::add_volatile_t<std::variant_alternative_t<I,T>>, and std::add_cv_t<std::variant_alternative_t<I,T>>

Contents



1 Member types

2 Helper template alias

3 Example

4 Defect reports

5 See also





[edit] Member types





  Member type



  Definition





  type



  the type of Ith alternative of the variant, where I must be in [0, sizeof...(Types)), otherwise the program is ill-formed.





[edit] Helper template alias





 template <size_t I, class T>

using variant_alternative_t = typename variant_alternative<I, T>::type;

 

 (since C++17) 







[edit] Example

Run this code

#include <variant>

#include <iostream>

 

using my_variant = std::variant<int, float>;

static_assert(std::is_same_v

    <int,   std::variant_alternative_t<0, my_variant>>);

static_assert(std::is_same_v

    <float, std::variant_alternative_t<1, my_variant>>);

// cv-qualification on the variant type propagates to the extracted alternative type.

static_assert(std::is_same_v

    <const int, std::variant_alternative_t<0, const my_variant>>);

 

int main()

{

    std::cout << "All static assertions passed.\n";

}

Output:



All static assertions passed.



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 2974



C++17



out-of-bounds index resulted in undefined behavior



made ill-formed



[edit] See also





  variant_sizevariant_size_v(C++17)



 obtains the size of the variant's list of alternatives at compile time(class template) (variable template)[edit]





  std::tuple_element<std::tuple>(C++11)



  obtains the type of the specified element  (class template specialization) [edit]









 





                    