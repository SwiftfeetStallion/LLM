std::optional[edit] Utilities library



Language support

Type support (basic types, RTTI)

Library feature-test macros (C++20)

Program utilities

Variadic functions

initializer_list(C++11)

is_constant_evaluated(C++20)

is_within_lifetime(C++26)

source_location(C++20)

Coroutine support (C++20)

Contract support (C++26)

Three-way comparison

three_way_comparablethree_way_comparable_with(C++20)(C++20)

strong_ordering(C++20)

weak_ordering(C++20)

partial_ordering(C++20)

common_comparison_category(C++20)

compare_three_way_result(C++20)

compare_three_way(C++20)

strong_order(C++20)

weak_order(C++20)

partial_order(C++20)

compare_strong_order_fallback(C++20)

compare_weak_order_fallback(C++20)

compare_partial_order_fallback(C++20)  





is_eqis_ltis_lteq(C++20)(C++20)(C++20)  



is_neqis_gtis_gteq(C++20)(C++20)(C++20)











General utilities



Function objects

Bit manipulation (C++20)

C-style bit manipulation (C++26)

bitset

hash(C++11)



Relational operators (deprecated in C++20)





rel_ops::operator!=rel_ops::operator>  



rel_ops::operator<=rel_ops::operator>=



Integer comparison functions



cmp_equalcmp_lesscmp_less_than(C++20)(C++20)(C++20)  



cmp_not_equalcmp_greatercmp_greater_than(C++20)(C++20)(C++20)



in_range(C++20)

Swap and type operations



swap

ranges::swap(C++20)

exchange(C++14)

declval(C++11)

to_underlying(C++23)



forward(C++11)

forward_like(C++23)

move(C++11)

move_if_noexcept(C++11)

as_const(C++17)



Common vocabulary types



pair

tuple(C++11)

optional(C++17)

any(C++17)

variant(C++17)



tuple_size(C++11)

tuple_element(C++11)

apply(C++17)

make_from_tuple(C++17)

expected(C++23)















[edit] std::optional

Member functions

optional::optional

optional::~optional

optional::operator=

Observers

optional::operator->optional::operator*

optional::operator booloptional::has_value

optional::value

optional::value_or

Iterators

optional::begin(C++26)

optional::end(C++26)

Monadic operations

optional::and_then(C++23)

optional::transform(C++23)

optional::or_else(C++23)

Modifiers

optional::emplace

optional::swap

optional::reset

Non-member functions

operator==operator!=operator<operator<=operator>operator>=operator<=>(C++20)

make_optional

swap(std::optional)

Deduction guides

Helper classes

hash<std::optional>

nullopt_t

in_place_t

bad_optional_access

Helper objects

nullopt

in_place

[edit] 





 constexpr const T* operator->() const noexcept;

 (1) 

 (since C++17) 





 constexpr T* operator->() noexcept;

 (2) 

 (since C++17) 





 constexpr const T& operator*() const& noexcept;

 (3) 

 (since C++17) 





 constexpr T& operator*() & noexcept;

 (4) 

 (since C++17) 





 constexpr const T&& operator*() const&& noexcept;

 (5) 

 (since C++17) 





 constexpr T&& operator*() && noexcept;

 (6) 

 (since C++17) 







Accesses the contained value.



1,2) Returns a pointer to the contained value.

3-6) Returns a reference to the contained value.







If has_value() is false, the behavior is undefined.





(until C++26)



If has_value() is false:



 If the implementation is hardened, a contract violation occurs. Moreover, if the contract-violation handler returns under “observe” evaluation semantic, the behavior is undefined.

 If the implementation is not hardened, the behavior is undefined.





(since C++26)



Contents



1 Return value

2 Notes

3 Example

4 Defect reports

5 See also





[edit] Return value

1,2) val

3,4) *val

5,6) std::move(*val ﻿)

[edit] Notes

This operator does not check whether *this contains a value, users can do so manually by using has_value() or operator bool(). Alternatively, if checked access is needed, value() or value_or() may be used.



[edit] Example

Run this code

#include <iomanip>

#include <iostream>

#include <optional>

#include <string>

 

int main()

{

    using namespace std::string_literals;

 

    std::optional<int> opt1{1};

    std::cout << "opt1: " << *opt1 << '\n';

 

    *opt1 = 2;

    std::cout << "opt1: " << *opt1 << '\n';

 

    std::optional<std::string> opt2{"abc"s};

    std::cout << "opt2: " << std::quoted(*opt2) << ", size: " << opt2->size() << '\n';

 

    // You can “take” the contained value by calling operator* on an rvalue to optional

    auto taken = *std::move(opt2);

    std::cout << "taken: " << std::quoted(taken) << "\n"

                 "opt2: " << std::quoted(*opt2) << ", size: " << opt2->size() << '\n';

}

Output:



opt1: 1

opt1: 2

opt2: "abc", size: 3

taken: "abc"

opt2: "", size: 0



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 2762



C++17



operator-> and operator* might be potentially-throwing



made noexcept



[edit] See also





  value



  returns the contained value  (public member function) [edit]





  value_or



  returns the contained value if available, another value otherwise  (public member function) [edit]









 





                    