Standard library header [edit] Standard library headers



Language support

<cfloat>

<climits>

<compare> (C++20)

<contracts> (C++26)

<coroutine> (C++20)

<csetjmp>

<csignal>

<cstdarg>

<cstddef>

<cstdint> (C++11)

<cstdlib>

<exception>

<initializer_list> (C++11)   

<limits>

<new>

<source_location> (C++20)

<stdfloat> (C++23)

<typeinfo>

<version> (C++20)

Concepts

<concepts> (C++20)

Diagnostics

<cassert>

<cerrno>

<debugging> (C++26)

<stacktrace> (C++23)

<stdexcept>

<system_error> (C++11)

Memory management

<memory>

<memory_resource> (C++17)

<scoped_allocator> (C++11)

Metaprogramming

<type_traits> (C++11)

<ratio> (C++11)







General utilities

<any> (C++17)

<bitset>

<bit> (C++20)

<charconv> (C++17)

<expected> (C++23)

<format> (C++20)

<functional>

<optional> (C++17)

<stdbit.h> (C++26)

<tuple> (C++11)

<typeindex> (C++11)

<utility>

<variant> (C++17)

Containers

<array> (C++11)

<deque>

<flat_map> (C++23)

<flat_set> (C++23)

<forward_list> (C++11)

<hive> (C++26)

<inplace_vector> (C++26)   

<list>

<map>

<mdspan> (C++23)

<queue>

<set>

<span> (C++20)

<stack>

<unordered_map> (C++11)

<unordered_set> (C++11)

<vector>

Iterators

<iterator>

Ranges

<generator> (C++23)

<ranges> (C++20)



Algorithms

<algorithm>

<numeric>

Strings

<cctype>

<cstring>

<cuchar> (C++11)

<cwchar>

<cwctype>

<string_view> (C++17)

<string>

Text processing

<clocale>

<codecvt> (C++11/17/26*)

<locale>

<regex> (C++11)

<text_encoding> (C++26)   

Numerics

<cfenv> (C++11)

<cmath>

<complex>

<linalg> (C++26)

<numbers> (C++20)

<random> (C++11)

<simd> (C++26)

<stdckdint.h> (C++26)

<valarray>

Time

<chrono> (C++11)

<ctime>

C compatibility

<ccomplex> (C++11/17/20*)

<ciso646> (until C++20)

<cstdalign> (C++11/17/20*)

<cstdbool> (C++11/17/20*)

<ctgmath> (C++11/17/20*)



Input/output

<cinttypes> (C++11)

<cstdio>

<filesystem> (C++17)

<fstream>

<iomanip>

<iosfwd>

<iostream>

<ios>

<istream>

<ostream>

<print> (C++23)

<spanstream> (C++23)

<sstream>

<streambuf>

<strstream> (C++98/26*)

<syncstream> (C++20)

Concurrency support

<atomic> (C++11)

<barrier> (C++20)

<condition_variable> (C++11)

<future> (C++11)

<hazard_pointer> (C++26)

<latch> (C++20)

<mutex> (C++11)

<rcu> (C++26)

<semaphore> (C++20)

<shared_mutex> (C++14)

<stdatomic.h> (C++23)

<stop_token> (C++20)

<thread> (C++11)

Execution support

<execution> (C++17)



















[edit] 

This header is part of the error handling library.







 Contents



1 Types

2 Functions

3 Synopsis



3.1 Class std::exception

3.2 Class std::bad_exception

3.3 Class std::nested_exception





4 See also





  Types





  exception



  base class for exceptions thrown by the standard library components  (class) [edit]





  nested_exception(C++11)



  a mixin type to capture and store current exceptions  (class) [edit]





  bad_exception



  exception thrown when std::current_exception fails to copy the exception object  (class) [edit]





  unexpected_handler(deprecated in C++11)(removed in C++17)



  the type of the function called by std::unexpected  (typedef) [edit]





  terminate_handler



  the type of the function called by std::terminate  (typedef) [edit]





  exception_ptr(C++11)



  shared pointer type for handling exception objects  (typedef) [edit]





   Functions





  unexpected(deprecated in C++11)(removed in C++17)



  function called when dynamic exception specification is violated  (function) [edit]





  uncaught_exceptionuncaught_exceptions(removed in C++20*)(C++17)



  checks if exception handling is currently in progress  (function) [edit]





  make_exception_ptr(C++11)



  creates an std::exception_ptr from an exception object  (function template) [edit]





  current_exception(C++11)



  captures the current exception in a std::exception_ptr  (function) [edit]





  rethrow_exception(C++11)



  throws the exception from an std::exception_ptr  (function) [edit]





  throw_with_nested(C++11)



  throws its argument with std::nested_exception mixed in  (function template) [edit]





  rethrow_if_nested(C++11)



  throws the exception from a std::nested_exception  (function template) [edit]





  terminate



  function called when exception handling fails  (function) [edit]





  get_terminate(C++11)



  obtains the current terminate_handler  (function) [edit]





  set_terminate



  changes the function to be called by std::terminate  (function) [edit]





  get_unexpected(deprecated in C++11)(removed in C++17)



  obtains the current unexpected_handler  (function) [edit]





  set_unexpected(deprecated in C++11)(removed in C++17)



  changes the function to be called by std::unexpected  (function) [edit]





[edit] Synopsis

// all freestanding

namespace std {

  class exception;

  class bad_exception;

  class nested_exception;

 

  using terminate_handler = void (*)();

  terminate_handler get_terminate() noexcept;

  terminate_handler set_terminate(terminate_handler f) noexcept;

  [[noreturn]] void terminate() noexcept;

 

  constexpr int uncaught_exceptions() noexcept;

 

  using exception_ptr = /* unspecified */;

 

  constexpr exception_ptr current_exception() noexcept;

  [[noreturn]] constexpr void rethrow_exception(exception_ptr p);

  template<class E> constexpr exception_ptr make_exception_ptr(E e) noexcept;

 

  template<class T> [[noreturn]] constexpr void throw_with_nested(T&& t);

  template<class E> constexpr void rethrow_if_nested(const E& e);

}

[edit] Class std::exception

namespace std {

  class exception

  {

  public:

    constexpr exception() noexcept;

    constexpr exception(const exception&) noexcept;

    constexpr exception& operator=(const exception&) noexcept;

    constexpr virtual ~exception();

    constexpr virtual const char* what() const noexcept;

  };

}

[edit] Class std::bad_exception

namespace std {

  class bad_exception : public exception

  {

  public:

    // see description for the specification of the special member functions

    constexpr const char* what() const noexcept override;

  };

}

[edit] Class std::nested_exception

namespace std {

  class nested_exception

  {

  public:

    constexpr nested_exception() noexcept;

    constexpr nested_exception(const nested_exception&) noexcept = default;

    constexpr nested_exception& operator=(const nested_exception&) noexcept = default;

    constexpr virtual ~nested_exception() = default;

 

    // access functions

    [[noreturn]] constexpr void rethrow_nested() const;

    constexpr exception_ptr nested_ptr() const noexcept;

  };

 

  template<class T> [[noreturn]] constexpr void throw_with_nested(T&& t);

  template<class E> constexpr void rethrow_if_nested(const E& e);

}

[edit] See also

Error handling







 





                    