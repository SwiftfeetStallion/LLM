Standard library header [edit] Standard library headers



Language support

<cfloat>

<climits>

<compare> (C++20)

<contracts> (C++26)

<coroutine> (C++20)

<csetjmp>

<csignal>

<cstdarg>

<cstddef>

<cstdint> (C++11)

<cstdlib>

<exception>

<initializer_list> (C++11)   

<limits>

<new>

<source_location> (C++20)

<stdfloat> (C++23)

<typeinfo>

<version> (C++20)

Concepts

<concepts> (C++20)

Diagnostics

<cassert>

<cerrno>

<debugging> (C++26)

<stacktrace> (C++23)

<stdexcept>

<system_error> (C++11)

Memory management

<memory>

<memory_resource> (C++17)

<scoped_allocator> (C++11)

Metaprogramming

<type_traits> (C++11)

<ratio> (C++11)







General utilities

<any> (C++17)

<bitset>

<bit> (C++20)

<charconv> (C++17)

<expected> (C++23)

<format> (C++20)

<functional>

<optional> (C++17)

<stdbit.h> (C++26)

<tuple> (C++11)

<typeindex> (C++11)

<utility>

<variant> (C++17)

Containers

<array> (C++11)

<deque>

<flat_map> (C++23)

<flat_set> (C++23)

<forward_list> (C++11)

<hive> (C++26)

<inplace_vector> (C++26)   

<list>

<map>

<mdspan> (C++23)

<queue>

<set>

<span> (C++20)

<stack>

<unordered_map> (C++11)

<unordered_set> (C++11)

<vector>

Iterators

<iterator>

Ranges

<generator> (C++23)

<ranges> (C++20)



Algorithms

<algorithm>

<numeric>

Strings

<cctype>

<cstring>

<cuchar> (C++11)

<cwchar>

<cwctype>

<string_view> (C++17)

<string>

Text processing

<clocale>

<codecvt> (C++11/17/26*)

<locale>

<regex> (C++11)

<text_encoding> (C++26)   

Numerics

<cfenv> (C++11)

<cmath>

<complex>

<linalg> (C++26)

<numbers> (C++20)

<random> (C++11)

<simd> (C++26)

<stdckdint.h> (C++26)

<valarray>

Time

<chrono> (C++11)

<ctime>

C compatibility

<ccomplex> (C++11/17/20*)

<ciso646> (until C++20)

<cstdalign> (C++11/17/20*)

<cstdbool> (C++11/17/20*)

<ctgmath> (C++11/17/20*)



Input/output

<cinttypes> (C++11)

<cstdio>

<filesystem> (C++17)

<fstream>

<iomanip>

<iosfwd>

<iostream>

<ios>

<istream>

<ostream>

<print> (C++23)

<spanstream> (C++23)

<sstream>

<streambuf>

<strstream> (C++98/26*)

<syncstream> (C++20)

Concurrency support

<atomic> (C++11)

<barrier> (C++20)

<condition_variable> (C++11)

<future> (C++11)

<hazard_pointer> (C++26)

<latch> (C++20)

<mutex> (C++11)

<rcu> (C++26)

<semaphore> (C++20)

<shared_mutex> (C++14)

<stdatomic.h> (C++23)

<stop_token> (C++20)

<thread> (C++11)

Execution support

<execution> (C++17)



















[edit] 

This header is part of the ranges library.



Contents



1 Range concepts

2 Range access

3 Range primitives

4 Synopsis





[edit]  Range concepts 





 Defined in  namespace std::experimental::ranges 





  Range



  specifies that a type is a range, that is, it provides a begin iterator and an end sentinel  (concept) [edit]





  SizedRange



  specifies that a range knows its size in constant time  (concept) [edit]





  View



  specifies that a range is a view, that is, it has constant time copy/move/assignment  (concept) [edit]





  BoundedRange



  specifies that a range has identical iterator and sentinel types  (concept) [edit]





  InputRange



  specifies a range whose iterator type satisfies InputIterator  (concept) [edit]





  OutputRange



  specifies a range whose iterator type satisfies OutputIterator  (concept) [edit]





  ForwardRange



  specifies a range whose iterator type satisfies ForwardIterator  (concept) [edit]





  BidirectionalRange



  specifies a range whose iterator type satisfies BidirectionalIterator  (concept) [edit]





  RandomAccessRange



  specifies a range whose iterator type satisfies RandomAccessIterator  (concept) [edit]





[edit]  Range access 





 Defined in  namespace std::experimental::ranges 





  begincbegin



 returns an iterator to the beginning of a range(customization point object)[edit]





  endcend



 returns an iterator to the end of a range(customization point object)[edit]





  rbegincrbegin



 returns a reverse iterator to a range(customization point object)[edit]





  rendcrend



 returns a reverse end iterator to a range(customization point object)[edit]





[edit]  Range primitives 





 Defined in  namespace std::experimental::ranges 





  size



 obtains the size of a range whose size can be calculated in constant time(customization point object)[edit]





  empty



 checks whether a range is empty(customization point object)[edit]





  datacdata



 obtains a pointer to the beginning of a contiguous range(customization point object)[edit]





  iterator_tsentinel_t



 obtains the iterator and sentinel types of a range(alias template)[edit]





[edit]  Synopsis 

#include <experimental/ranges/iterator>

 

namespace std { namespace experimental { namespace ranges { inline namespace v1 {

 

namespace {

  constexpr /* unspecified */ begin = /* unspecified */;

  constexpr /* unspecified */ end = /* unspecified */;

  constexpr /* unspecified */ cbegin = /* unspecified */;

  constexpr /* unspecified */ cend = /* unspecified */;

  constexpr /* unspecified */ rbegin = /* unspecified */;

  constexpr /* unspecified */ rend = /* unspecified */;

  constexpr /* unspecified */ crbegin = /* unspecified */;

  constexpr /* unspecified */ crend = /* unspecified */;

}

 

namespace {

  constexpr /* unspecified */ size = /* unspecified */;

  constexpr /* unspecified */ empty = /* unspecified */;

  constexpr /* unspecified */ data = /* unspecified */;

  constexpr /* unspecified */ cdata = /* unspecified */;

}

 

template <class T>

using iterator_t = decltype(ranges::begin(declval<T&>()));

 

template <class T>

using sentinel_t = decltype(ranges::end(declval<T&>()));

 

template <class>

constexpr bool disable_sized_range = false;

 

template <class T>

struct enable_view { };

 

struct view_base { };

 

template <class T>

concept bool Range = /* see definition */;

 

template <class T>

concept bool SizedRange = /* see definition */;

 

template <class T>

concept bool View = /* see definition */;

 

template <class T>

concept bool BoundedRange = /* see definition */;

 

template <class T>

concept bool InputRange = /* see definition */;

 

template <class R, class T>

concept bool OutputRange = /* see definition */;

 

template <class T>

concept bool ForwardRange = /* see definition */;

 

template <class T>

concept bool BidirectionalRange = /* see definition */;

 

template <class T>

concept bool RandomAccessRange = /* see definition */;

 

}}}}





 





                    