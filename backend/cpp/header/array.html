Standard library header [edit] Standard library headers



Language support

<cfloat>

<climits>

<compare> (C++20)

<contracts> (C++26)

<coroutine> (C++20)

<csetjmp>

<csignal>

<cstdarg>

<cstddef>

<cstdint> (C++11)

<cstdlib>

<exception>

<initializer_list> (C++11)   

<limits>

<new>

<source_location> (C++20)

<stdfloat> (C++23)

<typeinfo>

<version> (C++20)

Concepts

<concepts> (C++20)

Diagnostics

<cassert>

<cerrno>

<debugging> (C++26)

<stacktrace> (C++23)

<stdexcept>

<system_error> (C++11)

Memory management

<memory>

<memory_resource> (C++17)

<scoped_allocator> (C++11)

Metaprogramming

<type_traits> (C++11)

<ratio> (C++11)







General utilities

<any> (C++17)

<bitset>

<bit> (C++20)

<charconv> (C++17)

<expected> (C++23)

<format> (C++20)

<functional>

<optional> (C++17)

<stdbit.h> (C++26)

<tuple> (C++11)

<typeindex> (C++11)

<utility>

<variant> (C++17)

Containers

<array> (C++11)

<deque>

<flat_map> (C++23)

<flat_set> (C++23)

<forward_list> (C++11)

<hive> (C++26)

<inplace_vector> (C++26)   

<list>

<map>

<mdspan> (C++23)

<queue>

<set>

<span> (C++20)

<stack>

<unordered_map> (C++11)

<unordered_set> (C++11)

<vector>

Iterators

<iterator>

Ranges

<generator> (C++23)

<ranges> (C++20)



Algorithms

<algorithm>

<numeric>

Strings

<cctype>

<cstring>

<cuchar> (C++11)

<cwchar>

<cwctype>

<string_view> (C++17)

<string>

Text processing

<clocale>

<codecvt> (C++11/17/26*)

<locale>

<regex> (C++11)

<text_encoding> (C++26)   

Numerics

<cfenv> (C++11)

<cmath>

<complex>

<linalg> (C++26)

<numbers> (C++20)

<random> (C++11)

<simd> (C++26)

<stdckdint.h> (C++26)

<valarray>

Time

<chrono> (C++11)

<ctime>

C compatibility

<ccomplex> (C++11/17/20*)

<ciso646> (until C++20)

<cstdalign> (C++11/17/20*)

<cstdbool> (C++11/17/20*)

<ctgmath> (C++11/17/20*)



Input/output

<cinttypes> (C++11)

<cstdio>

<filesystem> (C++17)

<fstream>

<iomanip>

<iosfwd>

<iostream>

<ios>

<istream>

<ostream>

<print> (C++23)

<spanstream> (C++23)

<sstream>

<streambuf>

<strstream> (C++98/26*)

<syncstream> (C++20)

Concurrency support

<atomic> (C++11)

<barrier> (C++20)

<condition_variable> (C++11)

<future> (C++11)

<hazard_pointer> (C++26)

<latch> (C++20)

<mutex> (C++11)

<rcu> (C++26)

<semaphore> (C++20)

<shared_mutex> (C++14)

<stdatomic.h> (C++23)

<stop_token> (C++20)

<thread> (C++11)

Execution support

<execution> (C++17)



















[edit] 

This header is part of the containers library.







 Contents



1 Includes

2 Classes

3 Functions



3.1 Range access





4 Synopsis



4.1 Class template std::array









 Includes





  <compare>(C++20)



 Three-way comparison operator support[edit]





  <initializer_list>(C++11)



 std::initializer_list class template[edit]





  Classes





  array(C++11)



  fixed-sized inplace contiguous array  (class template) [edit]





  tuple_size(C++11)



  obtains the number of elements of a tuple-like type  (class template) [edit]





  tuple_element(C++11)



  obtains the element types of a tuple-like type  (class template) [edit]





  std::tuple_size<std::array>(C++11)



  obtains the size of an array  (class template specialization) [edit]





  std::tuple_element<std::array>(C++11)



  obtains the type of the elements of array  (class template specialization) [edit]





  Functions





  operator==operator!=operator<operator<=operator>operator>=operator<=>(C++11)(C++11)(removed in C++20)(C++11)(removed in C++20)(C++11)(removed in C++20)(C++11)(removed in C++20)(C++11)(removed in C++20)(C++20)



  lexicographically compares the values of two arrays  (function template) [edit]





  std::swap(std::array)(C++11)



  specializes the std::swap algorithm  (function template) [edit]





  to_array(C++20)



  creates a std::array object from a built-in array  (function template) [edit]





  get(std::array)(C++11)



  accesses an element of an array  (function template) [edit]





   Range access 





  begincbegin(C++11)(C++14)



  returns an iterator to the beginning of a container or array  (function template) [edit]





  endcend(C++11)(C++14)



  returns an iterator to the end of a container or array  (function template) [edit]





  rbegincrbegin(C++14)



  returns a reverse iterator to the beginning of a container or array  (function template) [edit]





  rendcrend(C++14)



  returns a reverse end iterator for a container or array  (function template) [edit]





  sizessize(C++17)(C++20)



  returns the size of a container or array  (function template) [edit]





  empty(C++17)



  checks whether the container is empty  (function template) [edit]





  data(C++17)



  obtains the pointer to the underlying array  (function template) [edit]





[edit] Synopsis

// mostly freestanding

#include <compare>

#include <initializer_list>

 

namespace std {

  // class template array

  template<class T, size_t N>

  struct array; // partially freestanding

 

  template<class T, size_t N>

  constexpr bool operator==(const array<T, N>& x, const array<T, N>& y);

  template<class T, size_t N>

  constexpr /*synth-three-way-result*/<T> operator<=>(const array<T, N>& x,

                                                      const array<T, N>& y);

 

  // specialized algorithms

  template<class T, size_t N>

  constexpr void swap(array<T, N>& x, array<T, N>& y) noexcept(noexcept(x.swap(y)));

 

  // array creation functions

  template<class T, size_t N>

  constexpr array<remove_cv_t<T>, N> to_array(T (&a)[N]);

  template<class T, size_t N>

  constexpr array<remove_cv_t<T>, N> to_array(T (&&a)[N]);

 

  // tuple interface

  template<class T>

  struct tuple_size;

  template<size_t I, class T>

  struct tuple_element;

  template<class T, size_t N>

  struct tuple_size<array<T, N>>;

  template<size_t I, class T, size_t N>

  struct tuple_element<I, array<T, N>>;

  template<size_t I, class T, size_t N>

  constexpr T& get(array<T, N>&) noexcept;

  template<size_t I, class T, size_t N>

  constexpr T&& get(array<T, N>&&) noexcept;

  template<size_t I, class T, size_t N>

  constexpr const T& get(const array<T, N>&) noexcept;

  template<size_t I, class T, size_t N>

  constexpr const T&& get(const array<T, N>&&) noexcept;

}

[edit] Class template std::array

namespace std {

  template<class T, size_t N>

  struct array

  {

    // types

    using value_type             = T;

    using pointer                = T*;

    using const_pointer          = const T*;

    using reference              = T&;

    using const_reference        = const T&;

    using size_type              = size_t;

    using difference_type        = ptrdiff_t;

    using iterator               = /* implementation-defined */;

    using const_iterator         = /* implementation-defined */;

    using reverse_iterator       = std::reverse_iterator<iterator>;

    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

 

    // no explicit construct/copy/destroy for aggregate type

 

    constexpr void fill(const T& u);

    constexpr void swap(array&) noexcept(is_nothrow_swappable_v<T>);

 

    // iterators

    constexpr iterator begin() noexcept;

    constexpr const_iterator begin() const noexcept;

    constexpr iterator end() noexcept;

    constexpr const_iterator end() const noexcept;

 

    constexpr reverse_iterator rbegin() noexcept;

    constexpr const_reverse_iterator rbegin() const noexcept;

    constexpr reverse_iterator rend() noexcept;

    constexpr const_reverse_iterator rend() const noexcept;

 

    constexpr const_iterator cbegin() const noexcept;

    constexpr const_iterator cend() const noexcept;

    constexpr const_reverse_iterator crbegin() const noexcept;

    constexpr const_reverse_iterator crend() const noexcept;

 

    // capacity

    constexpr bool empty() const noexcept;

    constexpr size_type size() const noexcept;

    constexpr size_type max_size() const noexcept;

 

    // element access

    constexpr reference operator[](size_type n);

    constexpr const_reference operator[](size_type n) const;

    constexpr reference at(size_type n);             // freestanding-deleted

    constexpr const_reference at(size_type n) const; // freestanding-deleted

    constexpr reference front();

    constexpr const_reference front() const;

    constexpr reference back();

    constexpr const_reference back() const;

 

    constexpr T* data() noexcept;

    constexpr const T* data() const noexcept;

  };

 

  template<class T, class... U>

  array(T, U...) -> array<T, 1 + sizeof...(U)>;

}





 





                    