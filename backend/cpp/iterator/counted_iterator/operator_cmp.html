operator==,[edit] Iterator library

Iterator concepts



indirectly_readable(C++20)

indirectly_writable(C++20)

weakly_incrementable(C++20)

incrementable(C++20)

is-integer-likeis-signed-integer-like(C++20)(C++20)



sentinel_for(C++20)

sized_sentinel_for(C++20)

input_iterator(C++20)

output_iterator(C++20)

input_or_output_iterator(C++20)







forward_iterator(C++20)

bidirectional_iterator(C++20)

random_access_iterator(C++20)

contiguous_iterator(C++20)











Iterator primitives



input_iterator_tagoutput_iterator_tagforward_iterator_tagbidirectional_iterator_tagrandom_access_iterator_tagcontiguous_iterator_tag(C++20)



iter_value_titer_difference_titer_reference_titer_const_reference_titer_rvalue_reference_titer_common_reference_t(C++20)(C++20)(C++20)(C++23)(C++20)(C++20)



iterator(deprecated in C++17)

iterator_traits

incrementable_traits(C++20)

indirectly_readable_traits(C++20)











Algorithm concepts and utilities

Indirect callable concepts



indirectly_unary_invocableindirectly_regular_unary_invocable(C++20)(C++20)  



indirect_unary_predicate(C++20)

indirect_binary_predicate(C++20)



indirect_equivalence_relation(C++20)

indirect_strict_weak_order(C++20)



Common algorithm requirements



indirectly_movable(C++20)

indirectly_movable_storable(C++20)

indirectly_copyable(C++20)



indirectly_copyable_storable(C++20)  

indirectly_swappable(C++20)

indirectly_comparable(C++20)



permutable(C++20)

mergeable(C++20)

sortable(C++20)



Utilities



indirect_result_t(C++20)



projected(C++20)



projected_value_t(C++26)



Iterator adaptors



reverse_iterator

make_reverse_iterator(C++14)

move_iterator(C++11)

make_move_iterator(C++11)

default_sentinel_tdefault_sentinel(C++20)(C++20)

unreachable_sentinel_tunreachable_sentinel(C++20)(C++20)



front_insert_iterator

back_insert_iterator

inserter

insert_iterator

front_inserter

back_inserter

move_sentinel(C++20)







common_iterator(C++20)

counted_iterator(C++20)

basic_const_iterator(C++23)

const_iterator(C++23)

const_sentinel(C++23)

make_const_iterator(C++23)

make_const_sentinel(C++23)









Stream iterators



istream_iterator  

ostream_iterator



istreambuf_iterator

ostreambuf_iterator





Iterator customization points

ranges::iter_move(C++20)

ranges::iter_swap(C++20)





Iterator operations





advance

distance

prev(C++11)  

next(C++11)



ranges::advance(C++20)

ranges::distance(C++20)

ranges::prev(C++20)

ranges::next(C++20)







Range access





begincbegin(C++11)(C++14)

rbegincrbegin(C++14)(C++14)  



endcend(C++11)(C++14)

rendcrend(C++14)(C++14)  



sizessize(C++17)(C++20)

empty(C++17)

data(C++17)







[edit] std::counted_iterator

Member functions

counted_iterator::counted_iterator

counted_iterator::operator=

counted_iterator::base

counted_iterator::count

counted_iterator::operator*counted_iterator::operator->

counted_iterator::operator[]

counted_iterator::operator++counted_iterator::operator++(int)counted_iterator::operator+counted_iterator::operator+=counted_iterator::operator--counted_iterator::operator--(int)counted_iterator::operator-counted_iterator::operator-=

Non-member functions

operator==operator<=>(C++20)(C++20)

operator==(default_sentinel_t)(C++20)

operator+(C++20)

operator-(C++20)

operator-(default_sentinel_t)(C++20)

iter_move(C++20)

iter_swap(C++20)

Helper classes

iterator_traits<std::counted_iterator>(C++20)

[edit] 





 template< std::common_with<I> I2 >

    friend constexpr bool operator==(



        const counted_iterator& x, const counted_iterator<I2>& y );

 (1) 

 (since C++20) 





 template< std::common_with<I> I2 >

    friend constexpr strong_ordering operator<=>(



        const counted_iterator& x, const counted_iterator<I2>& y );

 (2) 

 (since C++20) 







Compares the underlying lengths (i.e. distances to the end).



1) Checks if the underlying lengths are equal.

2) Compares the underlying lengths with operator <=>.

The behavior is undefined if x and y do not point to elements of the same sequence. That is, there must exist some n such that std::next(x.base(), x.count() + n) and std::next(y.base(), y.count() + n) refer to the same element.

The <, <=, >, >=, and != operators are synthesized from operator<=> and operator== respectively.

This function template  is not visible to ordinary unqualified or qualified lookup, and can only be found by argument-dependent lookup when std::counted_iterator<I> is an associated class of the arguments.



Contents



1 Parameters

2 Return value

3 Notes

4 Example

5 See also





[edit] Parameters





 x, y



 -



 iterator adaptors



[edit] Return value

1) x.count() == y.count()

2) y.count() <=> x.count()

[edit] Notes

Since the length counts down, not up, the order of the arguments of operator<=> in the underlying comparison expression is reversed, i.e. y is lhs, x is rhs.



[edit] Example

Run this code

#include <initializer_list>

#include <iterator>

 

int main()

{

    static constexpr auto v = {1, 2, 3, 4, 5, 6};

    constexpr std::counted_iterator<std::initializer_list<int>::iterator>

        it1{v.begin(), 5},

        it2{v.begin(), 5},

        it3{v.begin() + 1, 4},

        it4{v.begin(), 0};

    static_assert(it1 == it2);

    static_assert(it2 != it3);

    static_assert(it2 <  it3);

    static_assert(it1 <= it2);

    static_assert(it3 != std::default_sentinel);

    static_assert(it4 == std::default_sentinel);

 

//  it2 == std::counted_iterator{v.begin(), 4}; // UB: operands do not refer to

                                                // elements of the same sequence

}



[edit] See also





  operator==(std::default_sentinel)(C++20)



  checks if the distance to the end is equal to ​0​  (function template) [edit]





  operator+(C++20)



  advances the iterator  (function template) [edit]





  operator-(C++20)



  computes the distance between two iterator adaptors  (function template) [edit]









 





                    