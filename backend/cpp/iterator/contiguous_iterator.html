std::contiguous_iterator









From cppreference.com





[edit] Iterator library

Iterator concepts



indirectly_readable(C++20)

indirectly_writable(C++20)

weakly_incrementable(C++20)

incrementable(C++20)

is-integer-likeis-signed-integer-like(C++20)(C++20)



sentinel_for(C++20)

sized_sentinel_for(C++20)

input_iterator(C++20)

output_iterator(C++20)

input_or_output_iterator(C++20)







forward_iterator(C++20)

bidirectional_iterator(C++20)

random_access_iterator(C++20)

contiguous_iterator(C++20)











Iterator primitives



input_iterator_tagoutput_iterator_tagforward_iterator_tagbidirectional_iterator_tagrandom_access_iterator_tagcontiguous_iterator_tag(C++20)



iter_value_titer_difference_titer_reference_titer_const_reference_titer_rvalue_reference_titer_common_reference_t(C++20)(C++20)(C++20)(C++23)(C++20)(C++20)



iterator(deprecated in C++17)

iterator_traits

incrementable_traits(C++20)

indirectly_readable_traits(C++20)











Algorithm concepts and utilities

Indirect callable concepts



indirectly_unary_invocableindirectly_regular_unary_invocable(C++20)(C++20)  



indirect_unary_predicate(C++20)

indirect_binary_predicate(C++20)



indirect_equivalence_relation(C++20)

indirect_strict_weak_order(C++20)



Common algorithm requirements



indirectly_movable(C++20)

indirectly_movable_storable(C++20)

indirectly_copyable(C++20)



indirectly_copyable_storable(C++20)  

indirectly_swappable(C++20)

indirectly_comparable(C++20)



permutable(C++20)

mergeable(C++20)

sortable(C++20)



Utilities



indirect_result_t(C++20)



projected(C++20)



projected_value_t(C++26)



Iterator adaptors



reverse_iterator

make_reverse_iterator(C++14)

move_iterator(C++11)

make_move_iterator(C++11)

default_sentinel_tdefault_sentinel(C++20)(C++20)

unreachable_sentinel_tunreachable_sentinel(C++20)(C++20)



front_insert_iterator

back_insert_iterator

inserter

insert_iterator

front_inserter

back_inserter

move_sentinel(C++20)







common_iterator(C++20)

counted_iterator(C++20)

basic_const_iterator(C++23)

const_iterator(C++23)

const_sentinel(C++23)

make_const_iterator(C++23)

make_const_sentinel(C++23)









Stream iterators



istream_iterator  

ostream_iterator



istreambuf_iterator

ostreambuf_iterator





Iterator customization points

ranges::iter_move(C++20)

ranges::iter_swap(C++20)





Iterator operations





advance

distance

prev(C++11)  

next(C++11)



ranges::advance(C++20)

ranges::distance(C++20)

ranges::prev(C++20)

ranges::next(C++20)







Range access





begincbegin(C++11)(C++14)

rbegincrbegin(C++14)(C++14)  



endcend(C++11)(C++14)

rendcrend(C++14)(C++14)  



sizessize(C++17)(C++20)

empty(C++17)

data(C++17)







[edit] 





 Defined in header <iterator>











 template< class I >

    concept contiguous_iterator =

        std::random_access_iterator<I> &&

        std::derived_from</*ITER_CONCEPT*/<I>, std::contiguous_iterator_tag> &&

        std::is_lvalue_reference_v<std::iter_reference_t<I>> &&

        std::same_as<std::iter_value_t<I>,

                     std::remove_cvref_t<std::iter_reference_t<I>>> &&

        requires(const I& i) {

            { std::to_address(i) } ->

              std::same_as<std::add_pointer_t<std::iter_reference_t<I>>>;



        };

 

 (since C++20) 







The contiguous_iterator concept refines random_access_iterator by providing a guarantee the denoted elements are stored contiguously in the memory.







Given an iterator i of a type that models contiguous_iterator, a sentinel s and a non-negative integer n:



 For any range [i, s), standard library functions can replace it with [std::to_address(i), std::to_address(i + ranges::distance(i, s))).

 For any range i + [​0​, n), standard library functions can replace it with std::to_address(i) + [​0​, std::to_address(i + n)).



This means a program cannot rely on any side effects of dereferencing, incrementing or decrementing a contiguous iterator i, because standard library functions might operate on pointers obtained by std::to_address(i) instead of operating on i directly.





(since C++26)



Contents



1 Iterator concept determination

2 Semantic requirements

3 Equality preservation

4 Implicit expression variations

5 Notes

6 Defect reports

7 See also





[edit] Iterator concept determination

Definition of this concept is specified via an exposition-only alias template /*ITER_CONCEPT*/.

In order to determine /*ITER_CONCEPT*/<I>, let ITER_TRAITS<I> denote I if the specialization std::iterator_traits<I> is generated from the primary template, or std::iterator_traits<I> otherwise:



 If ITER_TRAITS<I>::iterator_concept is valid and names a type, /*ITER_CONCEPT*/<I> denotes the type.

 Otherwise, if ITER_TRAITS<I>::iterator_category is valid and names a type, /*ITER_CONCEPT*/<I> denotes the type.

 Otherwise, if std::iterator_traits<I> is generated from the primary template, /*ITER_CONCEPT*/<I> denotes std::random_access_iterator_tag.(That is, std::derived_from</*ITER_CONCEPT*/<I>, std::contiguous_iterator_tag> is assumed to be false.)

 Otherwise, /*ITER_CONCEPT*/<I> does not denote a type and results in a substitution failure.



[edit] Semantic requirements

Let a and b be dereferenceable iterators and c be a non-dereferenceable iterator of type I such that b is reachable from a and c is reachable from b, the type I models contiguous_iterator only if all the concepts it subsumes are modeled and all following conditions are satisfied:



 std::to_address(a) == std::addressof(*a).

 std::to_address(b) == std::to_address(a) + std::iter_difference_t<I>(b - a).

 std::to_address(c) == std::to_address(a) + std::iter_difference_t<I>(c - a).

 std::to_address(I{}) is well-defined.

 ranges::iter_move(a) has the same type, value category, and effects as std::move(*a).

 If ranges::iter_swap(a, b) is well-formed, it has effects equivalent to ranges::swap(*a, *b).



[edit] Equality preservation

Expressions declared in requires expressions of the standard library concepts are required to be equality-preserving (except where stated otherwise).



[edit] Implicit expression variations

A requires expression that uses an expression that is non-modifying for some constant lvalue operand also requires implicit expression variations.



[edit] Notes

contiguous_iterator is modeled by every pointer type to complete object type.

Iterator types in the standard library that are required to satisfy the LegacyContiguousIterator requirements in C++17 are also required to model contiguous_iterator in C++20.



[edit] Defect reports

The following behavior-changing defect reports were applied retroactively to previously published C++ standards.







DR



Applied to



Behavior as published



Correct behavior





LWG 3607



C++20



contiguous_iterator could have customranges::iter_move and ranges::iter_swap behaviors



prohibited





LWG 4170



C++20



a pair of value-initialized contiguous_iteratorsmight not be able to represent an empty range



guaranteed



[edit] See also





  random_access_iterator(C++20)



  specifies that a bidirectional_iterator is a random-access iterator, supporting advancement in constant time and subscripting  (concept) [edit]









 





                    